#include "RPG.dh"

#include "Augs.dh"
#include "ItemData.dh"
#include "Map.dh"
#include "Shield.dh"
#include "Shop.dh"
#include "Stats.dh"
#include "Skills.dh"
#include "Utils.dh"

// Globals
static int XPCurve;

// Stat Caps
int SoftStatCap = 100;
int HardStatCap = 1000;

// XP & Rank Tables
static long int[MAX_LEVEL] XPTable;
static long int[MAX_RANK] RankTable;

// Rank strings
static str[MAX_RANK + 1] Ranks =
{
    "Rec";
    "Pvt"; "Pvt +";
    "PFC"; "PFC +";
    "LCpl"; "LCpl +";
    "Cpl"; "Cpl +";
    "Sgt"; "Sgt +";
    "SSgt"; "SSgt +";
    "GySgt"; "GySgt +";
    "MSgt"; "MSgt +";
    "1stSgt"; "1stSgt +";
    "MGySgt"; "MGySgt +";
    "SgtMaj"; "SgtMaj +";
    "SgtMajMarCor"; "MSgtMarCor";
};

static str[MAX_RANK + 1] LongRanks =
{
    "Recruit";
    "Private"; "Private +";
    "Private First Class"; "Private First Class +";
    "Lance Corporal"; "Lance Corporal +";
    "Corporal"; "Corporal +";
    "Sergeant"; "Sergeant +";
    "Staff Sergeant"; "Staff Sergeant +";
    "Gunnery Sergeant"; "Gunnery Sergeant +";
    "Master Sergeant"; "Master Sergeant +";
    "First Sergeant"; "First Sergeant +";
    "Master Gunnery Sergeant"; "Master Gunnery Sergeant +";
    "Sergeant Major"; "Sergeant Major +";
    "Sergeant Major of the Marine Corps"; "Master Sergeant Major of the Marine Corps";
};

acscript void StatusEffect(int Type, int Time, int Intensity)
{
    if (Intensity <= 0)
        Intensity = 1;
    
    if (Player.StatusType[Type])
    {
        if (Intensity > Player.StatusIntensity[Type])
            Player.StatusIntensity[Type] = Intensity;
        
        Player.StatusTimer[Type] += Time * 35;
        
        if (Player.StatusTimer[Type] > Player.StatusTimerMax[Type])
            Player.StatusTimerMax[Type] = Player.StatusTimer[Type];
    }
    else
    {
        Player.StatusType[Type] = true;
        Player.StatusIntensity[Type] = Intensity;
        Player.StatusTimer[Type] = Time * 35;
        Player.StatusTimerMax[Type] = Player.StatusTimer[Type];
    };
};

acscript void TestStatusEffect(int Effect, int Length, int Intensity)
{
    Player.StatusType[Effect] = true;
    Player.StatusIntensity[Effect] = Intensity;
    Player.StatusTimer[Effect] = Length;
    Player.StatusTimerMax[Effect] = Length;
};

// Add XP
acscript void AddXP(int PlayerNum, long int XP, long int Rank, bool Reduced)
{
    // Scale XP/Rank Gains using the XP Scaling Option
    switch (GetCVar("drpg_scalexp"))
    {
    case 2: XP *= 2;                break;  // 2x
    case 3: XP *= 4;                break;  // 4x
    case 4: XP *= 8;                break;  // 8x
    case 5: XP = XP * 3 / 4;        break;  // 0.75x
    case 6: XP /= 2;                break;  // 0.5x
    case 7: XP /= 4;                break;  // 0.25x
    };
    
    if (GetCVar("drpg_combo"))
    {
        Players(PlayerNum).ComboTimer = COMBO_MAX;
        Players(PlayerNum).Combo++;
        
        if (Reduced)
        {
            if (XP > 0)
                Players(PlayerNum).XPGained += XP / 3;
        }
        else
        {
            if (XP > 0)
                Players(PlayerNum).XPGained += XP;
            Players(PlayerNum).RankGained += Rank;
        };
        
        if (Players(PlayerNum).Aura[AURA_WHITE])
        {
            if (Players(PlayerNum).AuraTimer > 0)
                Players(PlayerNum).Combo++;
            if (Player.SkillLevel[2][2].CurrentLevel >= 3 && XP > 0 && Rank > 0)
                Players(PlayerNum).BonusGained += XP + Rank;
        };
    }
    else
    {
        if (Reduced)
        {
            if (XP > 0)
                Players(PlayerNum).XP += XP / 3;
            Players(PlayerNum).Rank += Rank / 3;
        }
        else
        {
            if (XP > 0)
                Players(PlayerNum).XP += XP;
            Players(PlayerNum).Rank += Rank;
        };
    };
};

function void InitTables()
{
    // XP
    XPTable[0] = 200 + XPCurve;
    for (int i = 1; i < MAX_LEVEL; i++)
        XPTable[i] = ((XPTable[i - 1] / 2000) + 1) * (200 + XPCurve) + XPTable[i - 1];
    
    // Rank
    RankTable[0] = 7500 + (XPCurve * 50);
    for (int i = 1; i < MAX_RANK; i++)
        RankTable[i] = ((RankTable[i - 1] / 20000) + 1) * (7500 + (XPCurve * 50)) + RankTable[i - 1];
};

function void CheckCombo()
{
    if (GetCVar("drpg_combo"))
    {
        // Time Freeze special handling
        if (Player.Combo > 0 && CheckInventory("PowerTimeFreezer") && Player.ComboTimer >= COMBO_MAX)
            Player.ComboTimer = COMBO_MAX - 1;
        
        // Subtract the combo timer each tic
        if ((Player.Combo > 0 || Player.ComboTimer < COMBO_MAX) && !CheckInventory("PowerTimeFreezer") && !CheckInventory("DRPGMenuFreezer"))
            Player.ComboTimer--;
        
        // Reset values if you start the combo again while it was cooling down
        if (Player.ComboTimer == COMBO_MAX)
        {
            Player.BonusGained = 0;
            Player.XPGained = 0;
            Player.RankGained = 0;
        };
        
        // Add up and randomize the XP and Rank gain
        if (Player.ComboTimer == COMBO_STOP)
        {
            int ComboBonus = (int)((((fixed)Player.Combo / (fixed)GameSkill()) * (Player.XPGained + Player.RankGained)) / 10.0);
            if (ComboBonus < 0) ComboBonus = 0;
            
            // You cannot gain Negative XP, but you can lose Rank
            if (Player.XPGained < 0) Player.XPGained = 0;
            
            if (Player.Combo > 1)
            {
                Player.BonusGained += ComboBonus;
                Player.XP += Player.XPGained + ComboBonus;
                Player.Rank += Player.RankGained + ComboBonus;
            }
            else
            {
                Player.XP += Player.XPGained;
                Player.Rank += Player.RankGained;
            };
            
            Player.XPGained = 0;
            Player.RankGained = 0;
        };
        
        if (Player.ComboTimer < 0)
        {
            Player.Combo = 0;
            Player.ComboTimer = COMBO_MAX;
            Player.BonusGained = 0;
            Player.XPGained = 0;
            Player.RankGained = 0;
        };
    }
    else
        Player.ComboTimer = 0;
};

// Keeps current level and XP updated
function void CheckLevel()
{
    // Prevent underflow
    if (Player.XP < 0)
        Player.XP = 0;
    
    if (Player.Level < MAX_LEVEL)
        Player.XPNext = XPTable[Player.Level];
    
    if (Player.Level >= MAX_LEVEL)
    {
        Player.XP = XPTable[MAX_LEVEL - 1];
        Player.XPNext = XPTable[MAX_LEVEL - 1];
    };
    
    // Now check for a level up
    if (Player.XP >= XPTable[Player.Level] && Player.Level < MAX_LEVEL)
    {
        int StatTokens;
        int SkillTokens;
        
        if (GetCVar("drpg_levelup_type") == 0) // Skill-level
        {
            StatTokens = (6 - GameSkill()) + (Player.Level / 10);
            SkillTokens = (Player.Level % GameSkill()) == 1;
            
            // If you're on Armegeddon (DRLA), Only get one Stat Token per level
            if (GameSkill() == 6) StatTokens = 1;
            
            // If you're on easy, just give one Skill Token per level
            if (GameSkill() == 1) SkillTokens = 1;
        };
        if (GetCVar("drpg_levelup_type") == 1) // Static
        {
            StatTokens = 5 + (Player.Level / 10);
            SkillTokens = 1;
        };
        
        // Level Up
        ActivatorSound("misc/levelup", 96);
        
        Player.Level++;
        
        GiveInventory("DRPGStatToken", StatTokens);
        GiveInventory("DRPGSkillToken", SkillTokens);
        
        if (GetCVar("drpg_levelup_heal"))
        {
            if (Player.EP < 0) Player.EP = 0 else Player.EP = Player.EPMax;
            HealThing(1000000);
        };
        
        FadeRange(255, 255, 255, 0.5, 255, 255, 255, 0, 2.0);
        SetFont("BIGFONT");
        SetHudSize(0, 0, false);
        HudMessage("You have reached level %d\n", Player.Level,
                    HUDMSG_FADEOUT | HUDMSG_LOG, MENU_ID, CR_WHITE, 0.5, 0.4, 2.0, 2.0);
        
        SpawnForced("DRPGLevelUpArrow", GetActorX(0), GetActorY(0), GetActorZ(0) + GetActorPropertyFixed(Player.TID, APROP_Height), 0, 0);
    };
};

// Keeps current Rank updated
function void CheckRank()
{
    // Prevent underflow
    if (Player.Rank < 0)
        Player.Rank = 0;
    
    Player.RankString = Ranks[Player.RankLevel];
    
    if (Player.RankLevel < MAX_RANK)
        Player.RankNext = RankTable[Player.RankLevel];
    
    if (Player.RankLevel >= MAX_RANK)
    {
        Player.Rank = RankTable[MAX_RANK - 1];
        Player.RankNext = RankTable[MAX_RANK - 1];
    };
    
    // Rank Demotion
    if (Player.RankLevel > 0 && Player.Rank < RankTable[Player.RankLevel - 1])
    {
        Player.RankLevel--;
        FadeRange(255, 0, 64, 0.25, 255, 0, 64, 0, 2.0);
        
        SetFont("BIGFONT");
        SetHudSize(0, 0, false);
        HudMessage("You have been demoted to rank %d: %s\n",
                   Player.RankLevel, LongRanks[Player.RankLevel],
                   HUDMSG_FADEOUT | HUDMSG_LOG, MENU_ID + 1, CR_BRICK, 1.5, 0.5, 4.0, 2.0);
    };
    
    // Rank Promotion
    if (Player.Rank >= RankTable[Player.RankLevel] && Player.RankLevel < MAX_RANK)
    {
        int NewItems;
        
        Player.RankLevel++;

        ActivatorSound("misc/rankup", 96);
        FadeRange(255, 255, 0, 0.5, 255, 255, 0, 0, 2.0);
        
        // Determine how many new items you've unlocked in the shop
        for (int i = 0; i < ItemCategories; i++)
            for (int j = 0; j < ItemMax[i]; j++)
                if (ItemData[i][j].Rank == Player.RankLevel)
                    NewItems++;
        
        SetFont("BIGFONT");
        SetHudSize(0, 0, false);
        HudMessage("You have been promoted to rank %d: %s\n",
                   Player.RankLevel, LongRanks[Player.RankLevel],
                   HUDMSG_FADEOUT | HUDMSG_LOG, MENU_ID + 1, CR_GOLD, 1.5, 0.5, 4.0, 2.0);
        
        SpawnForced("DRPGRankUpArrow", GetActorX(0), GetActorY(0), GetActorZ(0) + GetActorPropertyFixed(Player.TID, APROP_Height), 0, 0);
        
        // Tells you if you've unlocked new items in the Shop
        if (NewItems > 0)
        {
            SetFont("SMALLFONT");
            HudMessage("You have unlocked %d new items in the shop\n", NewItems, HUDMSG_FADEOUT | HUDMSG_LOG, MENU_ID + 2, CR_GOLD, 0.5, 0.6, 4.0, 2.0);
        };
    };
    
    // Payment
    if (!CheckInventory("PowerTimeFreezer") && !CheckInventory("DRPGMenuFreezer"))
        Player.PayTimer--;
    if (Player.PayTimer <= 0)
    {
        if (Player.RankLevel > 0)
        {
            int Pay = CalculatePay();
            
            GiveInventory("DRPGCredits", Pay);
            
            FadeRange(0, 255, 0, 0.1, 0, 255, 0, 0, 2.0);
            DrawPay(Pay);
            ActivatorSound("credits/payout", 127);
            if (InMultiplayer && Arbitrator && PlayerCount() > 1)
                Log("\cfYour group has been paid by the UAC\n")
            else if (!InMultiplayer)
                Log("\cfYou have been paid %d Credits by the UAC\n", Pay);
        };
        
        Player.PayTimer = 35 * 60 * GetCVar("drpg_pay_interval");
        Player.PayKills = 0;
        Player.PayBonus++;
        
        // Cap Pay Bonus
        if (Player.PayBonus > 1000)
            Player.PayBonus = 1000;
    };
};

function void CheckHealth()
{
    // If you're dead, return
    if (ClassifyActor(0) & ACTOR_DEAD) return;
    
    // < 10% Health
    if (Player.ActualHealth <= Player.HealthMax / 10 && !Player.Perks[STAT_VITALITY])
    {
        // Fade Effect
        FadeRange(255, 0, 0, 0.15 + (Sin(Timer() / 64.0) * 0.1), 255, 0, 0, 0.0, 1.0);
        
        // Heartbeat
        if ((Timer() % 64) == 0 && Player.ActualHealth > 0)
            ActivatorSound("health/low", 64);
        
        // Halve Movement Speed and Jump Height
        Player.Speed /= 2;
        Player.JumpHeight /= 2;
    };
};

function void CheckStats()
{
    // VERY IMPORTANT CODE RIGHT HERE
    // If you're reading this and you'd like to modify stat curves, this is where you'd do it
    Player.LevelDamage = Player.Level * (10 - GameSkill());
    Player.BonusDamage = Player.Strength;
    Player.TotalDamage = Player.LevelDamage + Player.BonusDamage;
    Player.DamageFactor = 1.0 - 0.25 * ((fixed)Player.Defense / 100);
    Player.Mass = 100 + (Player.Defense * 10);
    Player.HealthMax = Player.Vitality * 10;
    Player.StatusEffectResist = Player.Vitality / 4.0;
    Player.EPMax = Player.Energy * 10;
    Player.AuraRange = Player.Energy * 16;
    Player.ToxicityRegenBonus = Player.Regeneration / 10;
    Player.Speed = 1.0 + 0.25 * ((fixed)Player.Agility / 100);
    Player.JumpHeight = 8.0 + (8.0 * ((fixed)Player.Agility / 100));
    Player.WeaponSpeed = Player.Agility;
    SetAmmoCapacity("Clip", Player.Capacity * 20);
    SetAmmoCapacity("Shell", Player.Capacity * 5);
    SetAmmoCapacity("RocketAmmo", Player.Capacity * 5);
    SetAmmoCapacity("Cell", Player.Capacity * 30);
    Player.Stim.VialMax = Player.Capacity * 10;
    Player.SurvivalBonus = (fixed)Player.Agility / 10.0;
    
    // Status Effect Checking
    if (Player.StatusType[SE_FATIGUE]) // Fatigue
    {
        Player.Speed = Player.Speed * (1.0 / ((fixed)Player.StatusIntensity[SE_FATIGUE] + 1));
        Player.JumpHeight = Player.JumpHeight * (1.0 / ((fixed)Player.StatusIntensity[SE_FATIGUE] + 1));
        
        if (Player.StatusIntensity[SE_FATIGUE] > 3)
            SetMugShotState("Rampage");
    };
    
    // Brutal Doom Compatibility
    if (GetCVar("drpg_ext_brutal"))
    {
        SetAmmoCapacity("NewClip", Player.Capacity * 20);
        SetAmmoCapacity("NewShell", Player.Capacity * 5);
        SetAmmoCapacity("NewRocket", Player.Capacity * 5);
        SetAmmoCapacity("NewCell", Player.Capacity * 30);
    };
};

function void CheckStatBonus()
{
    Player.Strength += Player.StrengthBonus;
    Player.Defense += Player.DefenseBonus;
    Player.Vitality += Player.VitalityBonus;
    Player.Energy += Player.EnergyBonus;
    Player.Regeneration += Player.RegenerationBonus;
    Player.Agility += Player.AgilityBonus;
    Player.Capacity += Player.CapacityBonus;
    Player.Luck += Player.LuckBonus;
    
    Player.StrengthBonus = 0;
    Player.DefenseBonus = 0;
    Player.VitalityBonus = 0;
    Player.EnergyBonus = 0;
    Player.RegenerationBonus = 0;
    Player.AgilityBonus = 0;
    Player.CapacityBonus = 0;
    Player.LuckBonus = 0;
};

function void CheckRegen()
{
    // Determine the max timer amounts
    Player.HPTime = (350 - (Player.Regeneration * 1.575) - (Player.AgilityTimer * 0.5)) * 2;
    Player.EPTime = (350 - (Player.Regeneration * 1.575) - (Player.AgilityTimer * 0.5)) * 2;
    
    // Cap Times
    if (Player.HPTime < 35)
        Player.HPTime = 35;
    if (Player.EPTime < 35)
        Player.EPTime = 35;
    
    // Determine the max regen amounts
    Player.HPAmount = 1 + Player.Vitality / 50;
    Player.EPAmount = 1 + Player.Energy / 50;
};

// Regeneration
function void DoRegen()
{
    int HPAmount = 1;
    int EPAmount = 1;
    int Overflow = 0;
    
    // HP Regen
    if (Player.HPRate >= Player.HPTime && ClassifyActor(Player.TID) & ACTOR_ALIVE)
        HealThing(Player.HPAmount);
    
    // EP Regen
    if (Player.EPRate >= Player.EPTime && Player.EP < Player.EPMax)
    {
        Player.EP += Player.EPAmount;
        Overflow = 0;
        
        if (Player.EP > Player.EPMax)
        {
            Overflow = Player.EP - Player.EPMax;
            Player.EP = Player.EPMax;
        };
        
        if (Player.Shield.Active && Player.Shield.Accessory && Player.Shield.Accessory->PassiveEffect == SHIELD_PASS_EPOVERFLOW)
        {
            HealThing(Overflow);
            Player.Shield.Charge += Overflow;
        };
    };
    
    // Check and Reset timers
    if (Player.HPRate >= Player.HPTime)
        Player.HPRate = 0;
    if (Player.EPRate >= Player.EPTime)
        Player.EPRate = 0;
    
    // Now increment the timers
    if (!CheckInventory("DRPGMenuFreezer"))
    {
        int Buttons = GetPlayerInput(PlayerNumber(), MODINPUT_BUTTONS);
        
        // Regen Boost
        if (Player.RegenBoostTimer > 0)
        {
            fixed X = GetActorX(0);
            fixed Y = GetActorY(0);
            fixed Z = GetActorZ(0);
            int Angle = GetActorAngle(0) * 256;
            SpawnForced("DRPGRegenSphereEffect", X, Y, Z + 32.0, AuraTID, Angle);
            
            Player.HPRate += Player.RegenBoostTimer / (GameSkill() * GameSkill());
            Player.EPRate += Player.RegenBoostTimer / (GameSkill() * GameSkill());
            Player.RegenBoostTimer--;
            
            // Pass Radius and Height to the Auras for DECORATE usage
            SetUserVariable(AuraTID, "user_radius", (int)GetActorPropertyFixed(Player.TID, APROP_Radius));
            SetUserVariable(AuraTID, "user_height", (int)GetActorPropertyFixed(Player.TID, APROP_Height));
            Thing_ChangeTID(AuraTID, 0);
        };
        
        // Regeneration Perk - Exponentially increase Health/Energy regeneration rates up to 4x as they lower
        if (Player.Perks[STAT_REGENERATION])
        {
            // Health
            fixed Health = Player.ActualHealth;
            fixed MaxHealth = Player.HealthMax;
            
            fixed Multiplier = (1.0 - (Health / MaxHealth)) * 1.7325;
            HPAmount += Multiplier * Multiplier;
            
            // EP
            fixed EP = Abs(Player.EP);
            fixed MaxEP = Player.EPMax;
            
            fixed Multiplier = (1.0 - (EP / MaxEP)) * 1.7325;
            EPAmount += Multiplier * Multiplier;
        };
        
        // Movement/Crouching/Idling mechanics
        if (GetCVar("drpg_regen_movement"))
        {
            if (IsPlayerMoving()) // Movement - 50% Regen Rate
            {
                Player.HPRate += HPAmount;
                Player.EPRate += EPAmount;
            }
            else if (Buttons & BT_CROUCH) // Crouch - 150% Regen Rate
            {
                Player.HPRate += HPAmount + 3;
                Player.EPRate += EPAmount + 3;
            }
            else // Idle - 100% Regen Rate
            {
                Player.HPRate += HPAmount + 2;
                Player.EPRate += EPAmount + 2;
            };
        }
        else
        {
            Player.HPRate += HPAmount;
            Player.EPRate += EPAmount;
        };
    };
};

function void ResetRegen()
{
    // If damaged, reset the Healing timer
    Player.HPRate = 0;
};

// Keep stats capped at certain values
function void CheckStatCaps()
{
    Player.StatCap = SoftStatCap + CheckInventory("DRPGStatCapToken");

    if (Player.Strength > Player.StatCap)       Player.Strength = Player.StatCap;
    if (Player.Defense > Player.StatCap)        Player.Defense = Player.StatCap;
    if (Player.Vitality > Player.StatCap)       Player.Vitality = Player.StatCap;
    if (Player.Energy > Player.StatCap)         Player.Energy = Player.StatCap;
    if (Player.Regeneration > Player.StatCap)   Player.Regeneration = Player.StatCap;
    if (Player.Agility > Player.StatCap)        Player.Agility = Player.StatCap;
    if (Player.Capacity > Player.StatCap)       Player.Capacity = Player.StatCap;
    if (Player.Luck > Player.StatCap)           Player.Luck = Player.StatCap;
};

// Keep stats capped at the hard value
function void CheckHardStatCaps()
{
    if (Player.Strength > HardStatCap)      Player.Strength = HardStatCap;
    if (Player.Defense > HardStatCap)       Player.Defense = HardStatCap;
    if (Player.Vitality > HardStatCap)      Player.Vitality = HardStatCap;
    if (Player.Energy > HardStatCap)        Player.Energy = HardStatCap;
    if (Player.Regeneration > HardStatCap)  Player.Regeneration = HardStatCap;
    if (Player.Agility > HardStatCap)       Player.Agility = HardStatCap;
    if (Player.Capacity > HardStatCap)      Player.Capacity = HardStatCap;
    if (Player.Luck > HardStatCap)          Player.Luck = HardStatCap;
};

function void CheckStatBounds()
{
    /* Prevent Overflow of EP - I'd rather we not do this, just for things like Stims
    if (Player.EP > Player.EPMax)
        Player.EP = Player.EPMax; */
    
    // Cap Defense/DamageFactor
    if (Player.DamageFactor < 0.1)
        Player.DamageFactor = 0.1;
    
    // Cap the max regen timer amounts to 1 second
    if (Player.HPTime < 35)
        Player.HPTime = 35;
    if (Player.EPTime < 35)
        Player.EPTime = 35;
    
    // Cap Status Effect Resistance
    if (Player.StatusEffectResist > 100.0)
        Player.StatusEffectResist = 100.0;
    
    // Cap Toxicity Regen Bonus
    if (Player.ToxicityRegenBonus > 20)
        Player.ToxicityRegenBonus = 20;
    
    // Prevent Shield Capacity from under/overflowing
    if (Player.Shield.Charge < 0)
        Player.Shield.Charge = 0;
    if (Player.Shield.Charge > Player.Shield.Capacity)
        Player.Shield.Charge = Player.Shield.Capacity;
    
    // Cap Shield stats
    if (Player.Shield.Capacity < 0)
        Player.Shield.Capacity = 0;
    if (Player.Shield.ChargeRate < 0)
        Player.Shield.ChargeRate = 0;
    if (Player.Shield.DelayRate < 1.0)
        Player.Shield.DelayRate = 1.0;
    
    // Cap Weapon Speed
    if (Player.WeaponSpeed > 100)
        Player.WeaponSpeed = 100;
    
    // Cap Survival Bonus
    if (Player.SurvivalBonus > 75 && (!Player.Shield.Accessory || Player.Shield.Accessory->PassiveEffect != SHIELD_PASS_ROULETTE))
        Player.SurvivalBonus = 75;
    
    // Cap chances at 100%
    if (Player.HealthChance > 100)  Player.HealthChance = 100;
    if (Player.EPChance > 100)      Player.EPChance = 100;
    if (Player.ArmorChance > 100)   Player.ArmorChance = 100;
    if (Player.PowerupChance > 100) Player.PowerupChance = 100;
    if (Player.WeaponChance > 100)  Player.WeaponChance = 100;
    if (Player.TokenChance > 100)   Player.TokenChance = 100;
    if (Player.AugChance > 100)     Player.AugChance = 100;
    if (Player.ShieldChance > 100)  Player.ShieldChance = 100;
    if (Player.StimChance > 100)    Player.StimChance = 100;

    // Speed capping CVAR
    if (Player.Speed > GetCVarFixed("drpg_maxspeed"))
        Player.Speed = GetCVarFixed("drpg_maxspeed");
        
    // Jump Height capping CVAR
    if (Player.JumpHeight > GetCVarFixed("drpg_maxjump"))
        Player.JumpHeight = GetCVarFixed("drpg_maxjump");
};

// Luck Chances
function void CheckLuck()
{
    Player.HealthChance = Player.Luck * LUCK_HEALTHCHANCE;
    Player.EPChance = Player.Luck * LUCK_EPCHANCE;
    Player.ArmorChance = Player.Luck * LUCK_ARMORCHANCE;
    Player.PowerupChance = Player.Luck * LUCK_POWERUPCHANCE;
    Player.WeaponChance = Player.Luck * LUCK_WEAPONCHANCE;
    Player.TokenChance = Player.Luck * LUCK_TOKENCHANCE;
    Player.AugChance = Player.Luck * LUCK_AUGCHANCE;
    Player.ShieldChance = Player.Luck * LUCK_SHIELDCHANCE;
    Player.StimChance = Player.Luck * LUCK_STIMCHANCE;
    
    // Hell Unleashed Map Event
    if (CurrentLevel->Event == MAPEVENT_HELLUNLEASHED)
    {
        Player.HealthChance += CurrentLevel->RareAdd;
        Player.EPChance += CurrentLevel->RareAdd;
        Player.ArmorChance += CurrentLevel->RareAdd;
        Player.PowerupChance += CurrentLevel->RareAdd;
        Player.WeaponChance += CurrentLevel->RareAdd;
        Player.TokenChance += CurrentLevel->RareAdd;
        Player.AugChance += CurrentLevel->RareAdd;
        Player.ShieldChance += CurrentLevel->RareAdd;
        Player.StimChance += CurrentLevel->RareAdd;
    };
};

function void CheckBurnout()
{
    // Energy Burnout Effect
    if (Player.EP < 0)
    {
        // Dynamic Intensity
        fixed Intensity = -((fixed)Player.EP / (fixed)Player.EPMax);
        if (Intensity > 0.75) Intensity = 0.75;
        
        // Screen Effect
        FadeRange(0, 128, 255, Intensity, 0, 128, 255, 0, 0.25);
        
        // Penalties
        Player.TotalDamage /= 2;
        Player.DamageFactor *= 2;
        Player.Mass /= 2;
        Player.HealthMax /= 2;
        Player.EPMax /= 2;
        Player.Speed /= 2;
        Player.JumpHeight /= 2;
        Player.SurvivalBonus /= 2;
        
        // Energy Perk
        if (Player.Perks[STAT_ENERGY])
            Player.EPTime /= 2;
    };
};

function void CheckPerks()
{
    // If you're dead, return
    if (GetActorProperty(Player.TID, APROP_Health) <= 0) return;
    
    if (Player.Strength >= 100)     Player.Perks[STAT_STRENGTH] = true      else Player.Perks[STAT_STRENGTH] = false;
    if (Player.Defense >= 100)      Player.Perks[STAT_DEFENSE] = true       else Player.Perks[STAT_DEFENSE] = false;
    if (Player.Vitality >= 100)     Player.Perks[STAT_VITALITY] = true      else Player.Perks[STAT_VITALITY] = false;
    if (Player.Energy >= 100)       Player.Perks[STAT_ENERGY] = true        else Player.Perks[STAT_ENERGY] = false;
    if (Player.Regeneration >= 100) Player.Perks[STAT_REGENERATION] = true  else Player.Perks[STAT_REGENERATION] = false;
    if (Player.Agility >= 100)      Player.Perks[STAT_AGILITY] = true       else Player.Perks[STAT_AGILITY] = false;
    if (Player.Capacity >= 100)     Player.Perks[STAT_CAPACITY] = true      else Player.Perks[STAT_CAPACITY] = false;
    if (Player.Luck >= 100)         Player.Perks[STAT_LUCK] = true          else Player.Perks[STAT_LUCK] = false;
    
    fixed StrengthPercent = ((fixed)Player.HealthMax / (fixed)Player.ActualHealth);
    fixed DefensePercent = ((fixed)Player.ActualHealth / (fixed)Player.HealthMax);
    
    // Cap Strength Percent
    if (StrengthPercent > 100)
        StrengthPercent = 100;
    
    // Cap Defense Percent
    if (DefensePercent < 0.01)
        DefensePercent = 0.01;
    if (DefensePercent > 1.0)
        DefensePercent = 1.0;
    
    // Strength Perk - Exponentially increase Strength as Health Decreases
    if (Player.Perks[STAT_STRENGTH] && StrengthPercent >= 1)
        Player.TotalDamage = (fixed)Player.TotalDamage * StrengthPercent;
    
    // Defense Perk - Exponentially increase Defense as Health Decreases
    if (Player.Perks[STAT_DEFENSE] && DefensePercent > 0)
        Player.DamageFactor *= DefensePercent;
    
    // Vitality Perk - Halve Health regeneration time
    if (Player.Perks[STAT_VITALITY] && Player.ActualHealth < Player.HealthMax / 10 + 1)
        Player.HPTime /= 2;
    
    // Agility Perk
    if (Player.Perks[STAT_AGILITY])
    {
        // Increment Agility timer to effect regeneration times the longer you are moving
        if (GetActorVelX(Player.TID) != 0 || GetActorVelY(Player.TID) != 0)
            Player.AgilityTimer++
        else
            Player.AgilityTimer = 0;
        
        // +30% Survival Bonus
        Player.SurvivalBonus += 30;
    };
    
    // Capacity Perk - Regenerate ammo
    if (Player.Perks[STAT_CAPACITY] && (Timer() % (35 * 30)) == 0)
    {
        GiveInventory("Clip", GetAmmoAmount("Clip"));
        GiveInventory("Shell", GetAmmoAmount("Shell"));
        GiveInventory("RocketAmmo", GetAmmoAmount("RocketAmmo"));
        GiveInventory("Cell", GetAmmoAmount("Cell"));
    };
    
    // Luck Perk - Always have Automap/Scanner
    // TODO: Ability to see secrets
    if (Player.Perks[STAT_LUCK])
    {
        GiveInventory("DRPGAllMapRevealer", 1);
        TakeInventory("PowerScanner", 1);
        GiveInventory("DRPGAllMapScanner", 1);
    };
};

function void CheckToxicity()
{
    // Prevent Underflow
    if (Player.Toxicity < 0)
        Player.Toxicity = 0;
    
    // Slowly decrease Toxicity
    if (Player.Toxicity > 0 && Timer() % (35 * (30 - Player.ToxicityRegenBonus)) == 0)
    {
        Player.Toxicity--;
        Player.ToxicTimer = 0;
        Player.ToxicOffset = 0;
        Player.ToxicStage = 0;
    };
    
    // Toxicity Penalties
    if (GetCVar("drpg_toxicity_penalties"))
    {
        if (Player.Toxicity >= 25 && Timer() % 35 == 0)
        {
            Player.HPRate = 0;
            Player.EPRate = 0;
        };
        if (Player.Toxicity >= 50 && Timer() % 35 == 0 && Player.EP > 0)
            Player.EP--;
        if (Player.Toxicity >= 75)
        {
            Player.Speed /= 2;
            Player.JumpHeight /= 2;
        };
    };
    
    // Death at 100% Toxicity
    if (Player.Toxicity >= 100)
    {
        Thing_Damage2(Player.TID, 1000000000, "Toxicity");
        Player.Toxicity = 0;
    };
};

function void ToxicityDamage()
{
    // Check Damage Type for Toxicity
    if (Player.DamageType == DT_TOXIC && !CheckInventory("PowerIronFeet") && !(Player.Shield.Accessory && Player.Shield.Accessory->PassiveEffect == SHIELD_PASS_NOTOXIC && Player.Shield.Active))
        AddToxicity(Random(1, GameSkill()));
};

function void CheckStatusEffects()
{
    if (Player.StatusType[SE_BLIND]) // Blind
        FadeRange(0, 0, 0, (0.5 + (Player.StatusIntensity[SE_BLIND] * 0.1)) - (Sin(Timer() / 128.0) * 0.25), 0, 0, 0, 0.0, 0.5);
    
    if (Player.StatusType[SE_CONFUSION]) // Confusion
    {
        SetHudSize(640, 480, true);
        SetFont(StrParam("P%iVIEW\n", PlayerNumber() + 1));
        
        fixed ViewCycle = Timer() / (120.0 - (10.0 * Player.StatusIntensity[SE_CONFUSION]));
        fixed ViewDist = 9.6 * Player.StatusIntensity[SE_CONFUSION] * ((fixed)Player.StatusTimer[SE_CONFUSION] / (fixed)Player.StatusTimerMax[SE_CONFUSION]);
        
        // View Spinning
        HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, CONFUSION_ID + 3, CR_UNTRANSLATED, 320, 240, 0.029);
        HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA | HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, CONFUSION_ID, CR_UNTRANSLATED,
                   320 + (int)(Cos(ViewCycle) * ViewDist),
                   240 + (int)(Sin(ViewCycle) * ViewDist),
                   0.029, 0.3);
        HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA | HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, CONFUSION_ID + 1, CR_UNTRANSLATED,
                   320 + (int)(Cos(ViewCycle + 0.333) * ViewDist),
                   240 + (int)(Sin(ViewCycle + 0.333) * ViewDist),
                   0.029, 0.6);
        HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA | HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, CONFUSION_ID + 2, CR_UNTRANSLATED,
                   320 + (int)(Cos(ViewCycle + 0.667) * ViewDist),
                   240 + (int)(Sin(ViewCycle + 0.667) * ViewDist),
                   0.029, 0.9);
        
        // Text Nonsense
        if (Random(1, 100 - (int)(((fixed)Player.StatusTimer[SE_CONFUSION] / (fixed)Player.StatusTimerMax[SE_CONFUSION]) * (10.0 * (fixed)Player.StatusIntensity[SE_CONFUSION]))) == 1)
        {
            auto char[26] Letters =
            {
                'A'; 'B'; 'C'; 'D'; 'E'; 'F';
                'G'; 'H'; 'I'; 'J'; 'K'; 'L';
                'M'; 'N'; 'O'; 'P'; 'Q'; 'R';
                'S'; 'T'; 'U'; 'V'; 'W'; 'X';
                'Y'; 'Z';
            };
            
            // Build a jibberish string
            int Length = Random(5, 30);
            char *Nonsense;
            
            // Fill the char array with garbage
            for (int i = 0; i < Length - 1; i++) 
                Nonsense[i] = Letters[Random(0, 25)];
            Nonsense[Length] = '\0';
            
            SetFont((Random(1, 4) == 1 ? "BIGFONT" : "SMALLFONT"));
            PrintTextWiggle(Nonsense, CONFUSION_NONSENSE_ID + Random(0, 10000), Random(0, 21), Random(160, 480), Random(120, 360), RandomFixed(1.0, 5.0), RandomFixed(32.0, 64.0), Random(8, 12), RandomFixed(16.0, 64.0));
        };
        
        // Sprite Nonsense
        if (Random(1, 100 - (int)(((fixed)Player.StatusTimer[SE_CONFUSION] / (fixed)Player.StatusTimerMax[SE_CONFUSION]) * (10.0 * (fixed)Player.StatusIntensity[SE_CONFUSION]))) == 1)
        {
            auto str[86] Sprites =
            {
                "TOKAA0"; "TOKBA0"; "TOKCA0";
                "AUGCA0"; "AUGUA0"; "AUGUB0"; "AUGBATT";
                "STIMB0";
                
                "PINVA0"; "PINSA0"; "PVISA0";
                "SOULA0"; "MEGAA0"; "CONTA0";
                
                "Stim1"; "Stim2"; "Stim3"; "Stim4";
                "Stim5"; "Stim6"; "Stim7"; "Stim8";
                "Stim9"; "Stim10"; "Stim11"; "Stim12";
                "Stim13"; "Stim14"; "Stim15"; "Stim16";
                "Stim17"; "Stim18"; "Stim19";
                
                "BarSBlnd"; "BarSConf"; "BarSPois"; "BarSCorr";
                "BarSViru"; "BarSFati"; "BarSSile"; "BarSEMP";
                "BarSCurs";
                
                "Fill1"; "Fill2"; "Fill3"; "Fill4";
                "Fill5"; "Fill6"; "Fill7"; "Fill8";
                "Fill9"; "Fill10"; "FillBar"; "FillShld";
                
                "MonLevel";
                "RankEmb"; "RankEmb1"; "RankEmb2"; "RankEmb3";
                "RankEmb4"; "RankEmb5"; "RankEmb6";
                
                "DamNum0"; "DamNum1"; "DamNum2"; "DamNum3";
                "DamNum4"; "DamNum5"; "DamNum6"; "DamNum7";
                "DamNum8"; "DamNum9";
                
                "STAT1S"; "STAT2S"; "STAT3S"; "STAT4S";
                "STAT5S"; "STAT6S"; "STAT7S"; "STAT8S";
                "STATP";
                
                "PRed"; "POrange"; "PYellow"; "PGreen";
                
                "M_DOOM";
            };
            
            PrintSpriteFade(Sprites[Random(0, 85)], CONFUSION_NONSENSE_ID + Random(0, 10000), Random(160, 480), Random(120, 360), RandomFixed(1.0, 3.0), RandomFixed(1.0, 2.0));
        };
        
        SetHudSize(0, 0, false);
    };
    
    if (Player.StatusType[SE_POISON]) // Poison
        if ((Timer() % 35) == 0)
            if (Player.ActualHealth - Player.StatusIntensity[SE_POISON] > 0)
            {
                Player.ActualHealth -= Player.StatusIntensity[SE_POISON];
                FadeRange(0, 255, 0, 0.25, 0, 255, 0, 0.0, Player.StatusIntensity[SE_POISON] * 0.25);
            };
    
    if (Player.StatusType[SE_CORROSION]) // Corrosion
        if ((Timer() % 35) == 0 && CheckInventory("Armor") > 0)
        {
            TakeInventory("BasicArmor", Player.StatusIntensity[SE_CORROSION]);
            FadeRange(0, 255, 0, 0.25, 0, 255, 0, 0.0, Player.StatusIntensity[SE_CORROSION] * 0.25);
        };
    
    if (Player.StatusType[SE_VIRUS]) // Virus
    {
        Player.HPRate -= 3 + Player.StatusIntensity[SE_VIRUS];
        Player.EPRate -= 3 + Player.StatusIntensity[SE_VIRUS];
    };
    
    if (Player.StatusType[SE_CURSE]) // Curse
        Player.DamageFactor = Player.DamageFactor * (1.0 * Player.StatusIntensity[SE_CURSE]);
    
    if (Player.StatusType[SE_EMP]) // EMP
    {
        if (Player.Shield.Active)
            ToggleShield();
        if (Player.Augs.SlotsUsed > 0)
            DisableAugs(true);
        if ((Timer() % 35) == 0)
            Player.Augs.Battery -= Player.StatusIntensity[SE_EMP];
        Player.Shield.Charge = 0;
    };
    
    if (Player.StatusType[SE_RADIATION]) // Radioactivity
    {
        // Geiger Sound Loop
        PlaySound(0, "misc/radiation", 7, 1.0, true, ATTN_NORM);
        
        if ((Timer() % 70) == 0)
        {
            // Trail Light
            SpawnForced("DRPGRadiationGlow2", GetActorX(0), GetActorY(0), GetActorZ(0) + (GetActorProperty(0, APROP_Height) / 2.0));
            
            // Poisoning
            if (Player.Toxicity < 85)
            {
                int i = Random(1, Player.StatusIntensity[SE_RADIATION]);
                if (Player.Toxicity + i > 85)
                    i = 85 - Player.Toxicity;
                AddToxicity(i);
                FadeRange(0, 255, 0, 0.25, 0, 255, 0, 0.0, i * 0.25);
            };
        };
        
        // Actor Light
        SpawnForced("DRPGRadiationGlow", GetActorX(0), GetActorY(0), GetActorZ(0) + (GetActorProperty(0, APROP_Height) / 2.0));
    };
    
    for (int i = 0; i < SE_MAX; i++)
    {
        // Disable an effect if the timer is 0
        if (Player.StatusType[i] && Player.StatusTimer[i] <= 0)
        {
            Player.StatusType[i] = false;
            Player.StatusIntensity[i] = 0;
            Player.StatusTimer[i] = 0;
            Player.StatusTimerMax[i] = 0;
            
            if (i == SE_RADIATION)
                StopSound(Player.TID, 7);
        }
        else if (Player.StatusTimer[i] > 0)
            Player.StatusTimer[i]--;
    };
};

function void StatusDamage(int Amount)
{
    int Type;
    int Time;
    int Intensity;
    int Count;
    int Chance;
    
    // Can't get Status Effects if Pink Aura is active
    if (Player.Aura[AURA_PINK] || Player.SoulActive[SOUL_PINK]) return;
    
    // Calculate the chance
    Chance = Random(0.0, 100.0);
    
    // Criticals boost 2.5x
    if (Amount >= Player.HealthMax / 2)
        Chance *= 2.5;
    
    // Damage Types
    switch (Player.DamageType)
    {
    case DT_TOXIC:
        if (Chance <= 20.0) // 1 in 5
        {
            switch (Random(1, 3))
            {
            case 1:
                Type = SE_POISON;
                Intensity = Random(1, 5);
                Time = Random(1, 5);
                break;
            case 2:
                Type == SE_CORROSION;
                Intensity = Random(1, 5);
                Time = Random(1, 5);
                break;
            case 3:
                Type = SE_RADIATION;
                Intensity = Random(1, 5);
                Time = Random(1, 10);
                break;
            };
        };
        break;
    case DT_MELEE:
        if (Chance <= 12.5) // 1 in 8
        {
            switch (Random(1, 3))
            {
            case 1:
                Type = SE_BLIND;
                Intensity = Random(1, 5);
                Time = Random(5, 10);
                break;
            case 2:
                Type = SE_CONFUSION;
                Intensity = Random(1, 5);
                Time = Random(5, 10);
                break;
            case 3:
                Type = SE_FATIGUE;
                Intensity = Random(1, 5);
                Time = Random(5, 30);
                break;
            };
        };
        break;
    case DT_PLASMA:
        if (Chance <= 12.5) // 1 in 8
        {
            switch (Random(1, 4))
            {
            case 1:
                Type = SE_POISON;
                Intensity = Random(1, 5);
                Time = Random(5, 20);
                break;
            case 2:
                Type == SE_CORROSION;
                Intensity = Random(1, 5);
                Time = Random(1, 5);
                break;
            case 3:
                Type = SE_VIRUS;
                Intensity = Random(1, 5);
                Time = Random(30, 120);
                break;
            case 4:
                Type == SE_CURSE;
                Intensity = Random(1, 5);
                Time = Random(10, 60);
                break;
            };
        };
        break;
    case DT_LIGHTNING:
        if (Chance <= 20.0) // 1 in 5
        {
            switch (Random(1, 4))
            {
            case 1:
                Type = SE_BLIND;
                Intensity = Random(1, 5);
                Time = Random(1, 10);
                break;
            case 2:
                Type == SE_SILENCE;
                Intensity = Random(1, 5);
                Time = Random(10 * Intensity, 30 * Intensity);
                break;
            case 3:
                Type = SE_EMP;
                Intensity = Random(1, 5);
                Time = Random(5, 30);
                break;
            case 4:
                Type = SE_RADIATION;
                Intensity = Random(1, 5);
                Time = Random(5, 20);
                break;
            };
        };
        break;
    case DT_FIRE:
        if (Chance <= 12.5) // 1 in 8
        {
            switch (Random(1, 2))
            {
            case 1:
                Type = SE_BLIND;
                Intensity = Random(1, 5);
                Time = Random(1, 10);
                break;
            case 2:
                Type = SE_FATIGUE;
                Intensity = Random(1, 5);
                Time = Random(5, 30);
                break;
            };
        };
        break;
    };
    
    if (Type > 0)
    {
        // Status Effect Resist check
        if (RandomFixed(0.0, 100.0) <= Player.StatusEffectResist)
            ActivatorSound("health/statuseffect2", 127)
        else // Apply status effect
        {
            ActivatorSound("health/statuseffect", 127);
            Player.StatusTypeHUD = Type;
            StatusEffect(Type, Time, Intensity);
        };
    };
};
