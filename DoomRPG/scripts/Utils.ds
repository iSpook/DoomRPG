#include "RPG.dh"

#include "Augs.dh"
#include "Defs.dh"
#include "ItemData.dh"
#include "Outpost.dh"
#include "Shield.dh"
#include "Shop.dh"
#include "Skills.dh"
#include "Stats.dh"
#include "Utils.dh"

int AuraTID = 20000;

// Skill Level Names
str[6] SkillLevels =
{
    "Easy";
    "Normal";
    "Hard";
    "Nightmare";
    "Hell";
};

str[AURA_MAX] AuraIcons =
{
    "AuraRed";
    "AuraGree";
    "AuraWhit";
    "AuraPink";
    "AuraCyan";
    "AuraPurp";
    "AuraOran";
    "AuraBlue";
    "AuraYell";
    "AuraBlac";
};

acscript int GetUniqueTID()
{
    return UniqueTID();
};

acscript int GetAmmoMax(int Type)
{
    switch (Type)
    {
    case AMMO_CLIP:     return GetAmmoCapacity("Clip");
    case AMMO_SHELL:    return GetAmmoCapacity("Shell");
    case AMMO_ROCKET:   return GetAmmoCapacity("RocketAmmo");
    case AMMO_CELL:     return GetAmmoCapacity("Cell");
    };
};

acscript void SoulEffect(int Type)
{
    Player.Aura[Type] = true;
    Player.AuraLevel[Type] = Skills[2][Type].MaxLevel;
    Player.AuraTimer += 30 * 35;
    Player.SoulActive[Type] = true;
};

acscript void PlayerTeleport(int PlayerNum)
{
    bool NearPlayers = true;
    
    if (PlayerNum == PlayerNumber() || !PlayerInGame(PlayerNum))
    {
        ActivatorSound("menu/error", 127);
        return;
    };
    
    // Teleport
    GiveInventory("DRPGPlayerTeleportGhost", 1);
    SetActorPosition(Player.TID, GetActorX(Players(PlayerNum).TID), GetActorY(Players(PlayerNum).TID), GetActorZ(Players(PlayerNum).TID), true);
    SetActorAngle(Player.TID, GetActorAngle(Players(PlayerNum).TID));
    SetActorProperty(Player.TID, APROP_RenderStyle, STYLE_Translucent);
    
    while (NearPlayers)
    {
        // Reset the flag
        NearPlayers = false;
        
        // Make sure you're not inside or near any other players before we solidify
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (i == PlayerNumber() || !PlayerInGame(i)) continue;
            if (Distance(Player.TID, Players(i).TID) <= GetActorPropertyFixed(Players(i).TID, APROP_Radius) + 16.0)
            {
                NearPlayers = true;
                break;
            };
        };
        
        // Player Flashyness
        SetActorPropertyFixed(Player.TID, APROP_Alpha, 0.75 + (Sin(Timer() / 32.0) * 0.25));
        
        // Solidify
        if (!NearPlayers)
        {
            GiveInventory("DRPGPlayerTeleportNormal", 1);
            SetActorProperty(Player.TID, APROP_RenderStyle, STYLE_Normal);
            SetActorPropertyFixed(Player.TID, APROP_Alpha, 1.0);
        };
        
        Delay(1);
    };
};

// Used by DECORATE and the Immunity Crystals plus Anti-Demon Field
acscript void DestroyImmunity()
{
    TakeInventory("DRPGPowerImmunityBullet", 1);
    TakeInventory("DRPGPowerImmunityMelee", 1);
    TakeInventory("DRPGPowerImmunityFire", 1);
    TakeInventory("DRPGPowerImmunityPlasma", 1);
    TakeInventory("PowerProtection", 1);
};

// Return the Skill Level (for DECORATE)
acscript int GetSkillLevel()
{
    return GameSkill();
};

// Return the Global shop card rank between all players (for DECORATE)
acscript int GetShopCard()
{
    return GlobalShopCard;
};

// Set the damage type recieved by the Player this tic (for DECORATE)
acscript void SetDamageType(int Type)
{
    Player.DamageType = Type;
};

// Add Toxicity to the Player
acscript void AddToxicity(int Amount)
{
    int PrevToxicity = Player.Toxicity;
    
    Player.Toxicity += Amount;
    Player.ToxicTimer = 0;
    Player.ToxicOffset = 0;
    Player.ToxicStage = 0;
    
    if ((PrevToxicity < 25 && Player.Toxicity >= 25) ||
        (PrevToxicity < 50 && Player.Toxicity >= 50) ||
        (PrevToxicity < 75 && Player.Toxicity >= 75))
        ActivatorSound("misc/toxic", 127);
};

// Return whether your Aug Battery is full or not1
acscript int CheckAugBatteryMax()
{
    return (Player.Augs.Battery >= Player.Augs.BatteryMax);
};

// Get the max inventory size
acscript int CheckInventoryMax()
{
    return Player.Capacity * 5;
};

// Used for handling inventory items using the Capacity stat
acscript int CheckCapacity()
{
    int Items = 0;
    int MaxItems = CheckInventoryMax();
    
    // Don't do checks if you have the system disabled
    if (!GetCVar("drpg_inv_capacity")) return true;
    
    auto str[] ItemList =
    {
        // Health
        "DRPGStimpack";
        "DRPGMedikit";
        "DRPGLargeMedikit";
        "DRPGXLMedikit";
        "DRPGMedPack";
        "DRPGSurgeryKit";
        
        // Armor
        "DRPGGreenArmor";
        "DRPGUsedGreenArmor";
        "DRPGBlueArmor";
        "DRPGUsedBlueArmor";
        "DRPGYellowArmor";
        "DRPGUsedYellowArmor";
        "DRPGRedArmor";
        "DRPGUsedRedArmor";
        "DRPGWhiteArmor";
        "DRPGUsedWhiteArmor";
        
        // Powerups
        "DRPGInvulnerabilitySphere";
        "DRPGInvulnerabilityCharge";
        "DRPGBlurSphere";
        "DRPGInvisibilityCharge";
        "DRPGTimeSphere";
        "DRPGRegenSphere";
        "DRPGRadSuit";
        "DRPGInfrared";
        "DRPGAllMap";
        "DRPGBerserk";
        "DRPGWings";
        
        // Stims
        "DRPGStimDetox";
        
        // Batteries
        "DRPGBatterySmall";
        "DRPGBatteryLarge";
        
        // DoomRL - Powerups
        "InvulnerabilitySphere2";
        "InvulnerabilityCharge2";
        "RadSuit2";
        "InvisibilityCharge2";
        "RadSuit2";
        "Infrared2";
        "Berserk2";
        
        // End of List
        nullptr;
    };
    
    for (int i = 0; ItemList[i] != nullptr; i++)
        if (CheckInventory(ItemList[i]) > 0)
            Items += CheckInventory(ItemList[i]);
    
    Player.InvItems = Items;
    
    if (Items >= MaxItems)
        return false
    else
        return true;
};

// Return Timer() for DECORATE
acscript int GetTimer()
{
    return Timer();
};

// Set Skill Level during the game
acscript void SetSkill(int NewSkill)
{
    if (NewSkill < 0 || NewSkill > (GetCVar("drpg_ext_doomrl") ? 5 : 4))
    {
        HudMessage("Invalid Skill Level\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
        return;
    };
    
    FadeRange(255, 255, 255, 0.5, 255, 255, 255, 0.0, 0.5);
    ChangeSkill(NewSkill);
    ActivatorSound("misc/secret", 127);
    SetFont("BIGFONT");
    HudMessageBold("\cjSkill Level has been changed to\n\cg%d - %s\n", NewSkill + 1, SkillLevels[NewSkill],
                   HUDMSG_FADEOUT, 0, CR_WHITE, 1.5, 0.5, 2.0, 1.0);
};

// Respec - Respecialize your Player
acscript void Respec(bool DoStats, bool DoSkills) net
{
    int StatPoints;
    int SkillPoints;
    int OldCredits;
    
    // Respec Stats
    if (DoStats)
    {
        // Add stats into a pool of tokens to give back to the player
        StatPoints += Player.Strength;
        StatPoints += Player.Defense;
        StatPoints += Player.Vitality - 10;
        StatPoints += Player.Energy - 10;
        StatPoints += Player.Regeneration;
        StatPoints += Player.Agility;
        StatPoints += Player.Capacity - 10;
        StatPoints += Player.Luck;
        
        // Reset Stats
        Player.Strength = 0;
        Player.Defense = 0;
        Player.Vitality = 10;
        Player.Energy = 10;
        Player.Regeneration = 0;
        Player.Agility = 0;
        Player.Capacity = 10;
        Player.Luck = 0;

        // Give Respecced Stat Tokens back
        GiveInventory("DRPGStatToken", StatPoints);

        // Reset Shield
        Player.Shield.Charge = 0;
        Player.Shield.Timer = 375;
    };
    
    // Respec Skills
    if (DoSkills)
    {
        // Reset skills, add skill levels together into a pool of tokens to give back to the player
        for (int i = 0; i < MAX_CATEGORIES; i++)
            for (int j = 0; j < MAX_SKILLS; j++)
                if (!(i == 5 && j == 7)) // Skip Transport
                    while (Player.SkillLevel[i][j].Level > 0)
                    {
                        SkillPoints += Player.SkillLevel[i][j].Level;
                        Player.SkillLevel[i][j].Level--;
                    };
        
        // Give Respecced Skill Tokens back
        GiveInventory("DRPGSkillToken", SkillPoints);

        // Remove Auras
        RemoveAura();
    };
    
    // Take 1/2 Credits
    GiveInventory("DRPGCredits", OldCredits);
    TakeInventory("DRPGCredits", CheckInventory("DRPGCredits") / 2);
    
    // FX
    FadeRange(255, 255, 255, 0.75, 0, 0, 0, 0.0, 2.5);
    SetFont("BIGFONT");
    HudMessage("Respec Complete\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.5, 2.5, 2.5);
    ActivatorSound("misc/secret", 127);
};

acscript void AddEP(int Amount, bool NoFlash)
{
    if (Player.EP + Amount > Player.EPMax)
        Amount = Player.EPMax - Player.EP;
    
    if (Amount <= 0)
        return;
    
    fixed FlashStrength = 0.01 * (Amount * 100 / Player.EPMax);
    fixed FlashDuration = 0.03 * (Amount * 100 / Player.EPMax);
    
    if (FlashStrength > 0.5)
        FlashStrength = 0.5;
    
    if (FlashDuration > 3.0)
        FlashDuration = 3.0;
    
    if (!NoFlash)
        FadeRange(0, 255, 255, FlashStrength, 0, 255, 255, 0, FlashDuration);
    
    Player.EP += Amount;
};

acscript void RemoveEP(int Amount, int InUnits)
{
    if (InUnits)
        Player.EP -= Amount
    else
        Player.EP -= ((Player.EP * Amount) / 100);
};

// Returns your current EP (for DECORATE)
acscript int GetEP()
{
    return Player.EP;
};

// Gets your current max EP (for DECORATE)
acscript int GetEPMax()
{
    return Player.EPMax;
};

// Returns the amount to heal given the percentage out of max HP (for DECORATE)
acscript int GetHealPercent(int Percent)
{
    return Player.HealthMax * Percent / 100;
};

// Returns your max Health (for DECORATE)
acscript int GetHealthMax()
{
    return Player.HealthMax;
};

// Used by DECORATE in UseShield state to cap healing items to only heal to maximum Health
acscript void CapHealthItem()
{
    if (Player.ActualHealth > Player.HealthMax)
        Player.ActualHealth = Player.HealthMax;
};

// Returns the capacity of your current Shield (for DECORATE)
acscript int GetShieldMax()
{
    return Player.Shield.Capacity;
};

// Returns the Agility for A_SetTics calls in DECORATE
acscript int GetSpeed(int Tics)
{
    return Tics - ((Tics - 1) / 100) * Player.Agility;
};

// Used by DECORATE to check if your Shield's stored Health is at max
acscript bool ShieldHealthMax()
{
    return (Player.ActualHealth >= Player.HealthMax);
};

// Used by DECORATE to check if both your Health and EP are at max
acscript bool HPEPMax()
{
    return (Player.ActualHealth >= Player.HealthMax && Player.EP >= Player.EPMax);
};

// Used by the RegenSphere to temporarily increase regen rates
acscript void RegenBoost()
{
    Player.RegenBoostTimer += (35 * 5) + ((Player.Regeneration / 13.33) * 35);
};

// HAAAAAAAAAAAAAAAX
acscript void Cheat(int StatBoost, int ItemMax)
{
    if (ItemMax == 0)
        ItemMax = 1000;
    
    // Max Level/Rank
    Player.XP = XPTable[MAX_LEVEL - 1];
    Player.Rank = RankTable[MAX_RANK - 1];
    Player.PayBonus = 1000;
    
    // Stats
    Player.Strength = StatBoost;
    Player.Defense = StatBoost;
    Player.Vitality = StatBoost;
    Player.Energy = StatBoost;
    Player.Regeneration = StatBoost;
    Player.Agility = StatBoost;
    Player.Capacity = StatBoost;
    Player.Luck = StatBoost;
    
    // Max out all Skills
    for (int i = 0; i < MAX_CATEGORIES; i++)
        for (int j = 0; j < MAX_SKILLS; j++)
        {
            Player.SkillLevel[i][j].Level = Skills[i][j].MaxLevel;
            Player.SkillLevel[i][j].CurrentLevel = Skills[i][j].MaxLevel;
        };
    
    // Items - Tokens
    SetInventory("DRPGStatToken", 10000);
    SetInventory("DRPGStatCapToken", 100);
    SetInventory("DRPGSkillToken", 10000);
    
    // Items - Health
    SetInventory("DRPGStimPack", ItemMax);
    SetInventory("DRPGMedikit", ItemMax);
    SetInventory("DRPGLargeMedikit", ItemMax);
    SetInventory("DRPGXLMedikit", ItemMax);
    SetInventory("DRPGMedPack", ItemMax);
    SetInventory("DRPGSurgeryKit", ItemMax);
    SetInventory("DRPGContinue", ItemMax);
    
    // Items - Armor
    if (!GetCVar("drpg_ext_doomrl"))
    {
        TakeInventory("BasicArmor", 1000000);
        SetInventory("DRPGGreenArmor", ItemMax);
        SetInventory("DRPGBlueArmor", ItemMax);
        SetInventory("DRPGYellowArmor", ItemMax);
        SetInventory("DRPGRedArmor", ItemMax);
        SetInventory("DRPGWhiteArmor", ItemMax);
    };
    
    // Items - Powerups
    SetInventory("DRPGInvulnerabilitySphere", ItemMax);
    SetInventory("DRPGInvulnerabilityCharge", ItemMax);
    SetInventory("DRPGBlurSphere", ItemMax);
    SetInventory("DRPGInvisibilityCharge", ItemMax);
    SetInventory("DRPGRadSuit", ItemMax);
    SetInventory("DRPGInfrared", ItemMax);
    SetInventory("DRPGBerserk", ItemMax);
    SetInventory("DRPGPowerStrength", 1);
    SetInventory("DRPGAllMap", ItemMax);
    
    // Items - Ammo
    SetInventory("Clip", GetAmmoCapacity("Clip"));
    SetInventory("Shell", GetAmmoCapacity("Shell"));
    SetInventory("RocketAmmo", GetAmmoCapacity("RocketAmmo"));
    SetInventory("Cell", GetAmmoCapacity("Cell"));
    
    // Items - Misc
    GiveAugs(100, 100, 100);
    GiveCredits(0);
    FullShield();
    GiveCompounds(10000);
    SetInventory("DRPGRedCard", 1);
    SetInventory("DRPGYellowCard", 1);
    SetInventory("DRPGBlueCard", 1);
    SetInventory("DRPGRedSkull", 1);
    SetInventory("DRPGYellowSkull", 1);
    SetInventory("DRPGBlueSkull", 1);
    SetInventory("PowerInvulnerable", 1);
    SetInventory("PowerShadow", 1);
    SetInventory("PowerIronFeet", 1);
    SetInventory("PowerLightAmp", 1);
    
    // Stims
    SetInventory("DRPGStimSmall", ItemMax);
    SetInventory("DRPGStimMedium", ItemMax);
    SetInventory("DRPGStimLarge", ItemMax);
    SetInventory("DRPGStimXL", ItemMax);
    SetInventory("DRPGStimDetox", ItemMax);
    
    // Restore HP/EP/Shields
    HealThing(Player.HealthMax);
    Player.EP = Player.EPMax;
    Player.Shield.Charge = Player.Shield.Capacity;
    Player.Shield.Timer = 0;
};

// For testing different stats and their effects
acscript void ModStat(int Stat, int Value)
{
    switch (Stat)
    {
    case STAT_STRENGTH + 1:     Player.Strength = Value;        break;
    case STAT_DEFENSE + 1:      Player.Defense = Value;         break;
    case STAT_VITALITY + 1:     Player.Vitality = Value;        break;
    case STAT_ENERGY + 1:       Player.Energy = Value;          break;
    case STAT_REGENERATION + 1: Player.Regeneration = Value;    break;
    case STAT_AGILITY + 1:      Player.Agility = Value;         break;
    case STAT_CAPACITY + 1:     Player.Capacity = Value;        break;
    case STAT_LUCK + 1:         Player.Luck = Value;            break;
    };
};

// Give Credits
acscript void GiveCredits(int Amount)
{
    if (Amount == 0) Amount = 1000000000;
    GiveInventory("DRPGCredits", Amount);
    ActivatorSound("credits/payout", 127);
};

// Instant payout
acscript void Payout(int Time)
{
    if (Time > 0)
        Player.PayTimer = Time
    else
        Player.PayTimer = 0;
};

// Shuffle the Shop Special
acscript void ShopSpecialShuffle()
{
    ShopSpecialTimer = 0;
};

// Give all Augs
acscript void GiveAugs(int Canisters, int Upgrades, int Slots)
{
    GiveInventory("DRPGAugCanister", Canisters);
    GiveInventory("DRPGAugUpgradeCanister", Upgrades);
    GiveInventory("DRPGAugSlotUpgrade", Slots);
    
    for (int i = 0; i < MAX_AUGS; i++)
    {
        AugInfoPtr AugPtr = &AugData[i];
        Player.Augs.Level[i] = AugPtr->MaxLevel;
    };
};

// Give all Shield Components
acscript void FullShield()
{
    // Bodies
    for (int i = 0; i < ShieldPartsMax[0]; i++)
    {
        ShieldPartPtr Part = &ShieldParts[0][i];
        GiveInventory(Part->Actor, 1);
    };
    
    // Batteries
    for (int i = 0; i < ShieldPartsMax[1]; i++)
    {
        ShieldPartPtr Part = &ShieldParts[1][i];
        GiveInventory(Part->Actor, 1);
    };

    // Capacitors
    for (int i = 0; i < ShieldPartsMax[2]; i++)
    {
        ShieldPartPtr Part = &ShieldParts[2][i];
        GiveInventory(Part->Actor, 1);
    };
    
    // Accessories
    for (int i = 0; i < MAX_ACCESSORIES; i++)
    {
        ShieldAccsPtr Accessory = &ShieldAccessories[i];
        GiveInventory(Accessory->Actor, 1);
    };
};

// Full Locker
acscript void FullLocker(int Amount, bool Global)
{
    for (int i = 0; i < ItemCategories; i++)
        for (int j = 0; j < ItemMax[i]; j++)
        {
            ItemInfoPtr ItemPtr = &ItemData[i][j];
            
            if (!ItemPtr->Unstorable)
                if (Global)
                    GlobalLocker[i][j] = Amount
                else
                    Player.Locker[i][j] = Amount;
        };
};

// Give all Stim Compounds
acscript void GiveCompounds(int Amount)
{
    for (int i = 0; i < MAX_COMPOUNDS; i++)
        if (Amount == 0)
            Player.Stim.Vials[i] = Player.Capacity * 10
        else
            Player.Stim.Vials[i] += Amount;
};

// For thrusting things with more realistic momentum handling
acscript void ThrustMomentum()
{
    fixed VelocityX = GetActorVelX(0);
    fixed VelocityY = GetActorVelY(0);
    fixed Angle = VectorAngle(VelocityX, VelocityY);
    int Force = Abs(VelocityX) + Abs(VelocityY);

    ThrustThing(Angle * 256, Force * 3, 0, 0);
    ThrustThingZ(0, Force * 4, 0, 1);
   
    Delay(4);
};

script void PrintTextWiggle(char *Text, int ID, int Color, int X, int Y, fixed HoldTime, fixed Speed, fixed Spacing, fixed Radius)
{
    int Time = (int)(HoldTime * 35.0);
    int TimeMax = Time;
    
    SetHudSize(640, 480, false);
    
    while (Time > 0)
    {
        for (int i = 0; Text[i] != NULL; i++)
        {
            fixed XOff = (fixed)X + (Spacing * i);
            fixed YOff = (fixed)Y + Sin((Timer() + i) / Speed) * Radius;
            HudMessage("%c\n", Text[i], HUDMSG_PLAIN | HUDMSG_ALPHA, ID + i, Color, (int)XOff, (int)YOff, 0.05, ((fixed)Time / (fixed)TimeMax));
        };
        
        Time--;
        Delay(1);
    };
};

function void CreateTranslations()
{
    // Damage Numbers - Critical
    CreateTranslationStart(DNUM_CRITICAL);
    CreateTranslationPalette(81, 111, 176, 176);
    CreateTranslationEnd();
    
    // Damage Numbers - Healed
    CreateTranslationStart(DNUM_HEAL);
    CreateTranslationPalette(81, 111, 112, 112);
    CreateTranslationEnd();

    // Damage Numbers - Scratch
    CreateTranslationStart(DNUM_SCRATCH);
    CreateTranslationPalette(81, 111, 100, 100);
    CreateTranslationEnd();
    
    // Credit Gain
    CreateTranslationStart(DNUM_CREDGAIN);
    CreateTranslationPalette(81, 111, 249, 249);
    CreateTranslationEnd();

    // Credit Loss
    CreateTranslationStart(DNUM_CREDLOSS);
    CreateTranslationPalette(81, 111, 248, 248);
    CreateTranslationEnd();
    
    // EP Gain
    CreateTranslationStart(DNUM_EPGAIN);
    CreateTranslationPalette(81, 111, 196, 196);
    CreateTranslationEnd();
    
    // EP Loss
    CreateTranslationStart(DNUM_EPLOSS);
    CreateTranslationPalette(81, 111, 200, 200);
    CreateTranslationEnd();
    
    // Shield Gain
    CreateTranslationStart(DNUM_SHIELDGAIN);
    CreateTranslationPalette(81, 111, 250, 250);
    CreateTranslationEnd();
    
    // Shield Loss
    CreateTranslationStart(DNUM_SHIELDLOSS);
    CreateTranslationPalette(81, 111, 251, 251);
    CreateTranslationEnd();
};

// PrintSprite Utility Function
function void PrintSprite(str Sprite, int ID, fixed X, fixed Y, fixed DelayTime)
{
    SetFont(Sprite);
    HudMessage("A\n", HUDMSG_PLAIN, ID, CR_UNTRANSLATED, X, Y, DelayTime);
};

function void PrintSpriteFade(str Sprite, int ID, fixed X, fixed Y, fixed DelayTime, fixed HoldTime)
{
    SetFont(Sprite);
    HudMessage("A\n", HUDMSG_FADEOUT, ID, CR_UNTRANSLATED, X, Y, DelayTime, HoldTime);
};

function void PrintSpriteAlpha(str Sprite, int ID, fixed X, fixed Y, fixed DelayTime, fixed Alpha)
{
    SetFont(Sprite);
    HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA, ID, CR_UNTRANSLATED, X, Y, DelayTime, Alpha);
};

function void PrintSpritePulse(str Sprite, int ID, fixed X, fixed Y, fixed Alpha, fixed Speed, fixed Radius, bool AddBlend)
{
    SetFont(Sprite);
    
    if (AddBlend)
        HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA | HUDMSG_ADDBLEND, ID, CR_UNTRANSLATED, X, Y, 0.05, Alpha + (Sin((fixed)Timer() / Speed) * Radius))
    else
        HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA, ID, CR_UNTRANSLATED, X, Y, 0.05, Alpha + (Sin((fixed)Timer() / Speed) * Radius));
};

function void ClearMessage(int ID)
{
    HudMessage("\n", HUDMSG_PLAIN, ID, CR_WHITE, 0, 0, 0.05);
};

function int CheckInventoryTID(int TID, str Item)
{
    return (TID == 0 ? CheckInventory(Item) : CheckActorInventory(TID, Item));
};

function int SetInventory(str Item, int Count)
{
    int n = Count - CheckInventory(Item);
    
    if (n > 0)
        GiveInventory(Item, n)
    else if (n < 0)
        TakeInventory(Item, -n);
    
    return n;
};

function int SetActorInventory(int tid, str item, int count)
{
    int n = count - CheckActorInventory (tid, item);
    
    if (n > 0)
        GiveActorInventory(tid, item, n)
    else if (n < 0)
        TakeActorInventory(tid, item, -1 * n);
    
    return n;
};

// Drop your entire inventory on the ground
function void DropInventory()
{
    auto DroppedItem[] ItemList =
    {
        // Health
        { "Stimpack"; };
        { "Medikit"; };
        { "LargeMedikit"; };
        { "XLMedikit"; };
        { "MedPack"; };
        { "SurgeryKit"; };
        { "Continue"; };
        
        // Armor
        { "GreenArmor"; };
        { "UsedGreenArmor"; };
        { "BlueArmor"; };
        { "UsedBlueArmor"; };
        { "YellowArmor"; };
        { "UsedYellowArmor"; };
        { "RedArmor"; };
        { "UsedRedArmor"; };
        { "WhiteArmor"; };
        { "UsedWhiteArmor"; };
        
        // Powerups
        { "InvulnerabilitySphere"; };
        { "InvulnerabilityCharge"; };
        { "BlurSphere"; };
        { "InvisibilityCharge"; };
        { "RegenSphere"; };
        { "RadSuit"; };
        { "Infrared"; };
        { "AllMap"; };
        { "Berserk"; };
        { "Wings"; };
        { "StimSmall"; };
        { "StimMedium"; };
        { "StimLarge"; };
        
        // DoomRL - Powerups
        { "InvulnerabilitySphere2"; };
        { "RadSuit2"; };
        { "Infrared2"; };
        { "Berserk2"; };

        // DoomRL - Modpacks
        { "RLPowerModItem"; };
        { "RLBulkModItem"; };
        { "RLAgilityModItem"; };
        { "RLTechnicalModItem"; };
        { "RLSniperModItem"; };
        { "RLFirestormModItem"; };
        { "RLNanoModItem"; };
        { "RLOnyxModItem"; };
        { "RLArmorModItem"; };
        { "RLModLimit"; true; true; 4; };
        { "RLScavengerModLimit"; true; true; 8; };
        { "RLArmorModItemInInventory"; true; };
        
        // End of list
        { nullptr; };
    };
    
    for (int i = 0; ItemList[i].Actor != nullptr; i++)
        for (int j = 0; j < CheckInventory(ItemList[i].Actor); j++)
        {
            // Limit the drops if you have more than 25 to prevent massive amounts of lag
            if (j >= 25) break;
            
            if (ItemList[i].TakeAll)
                TakeInventory(ItemList[i].Actor, ItemList[i].Max)
            else
                TakeInventory(ItemList[i].Actor, 1);
            
            if (!ItemList[i].NoDrop)
                DropItem(0, ItemList[i].Actor, 1, 255);
        };
};

function void DropMoney(int Killer, int TID, int Amount)
{
    int Total = Amount;
    int Drops;
    
    Drops = Total / 1000;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits1000", 256);
    Total %= 1000;

    Drops = Total / 100;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits100", 256);
    Total %= 100;

    Drops = Total / 50;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits50", 256);
    Total %= 50;

    Drops = Total / 20;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits20", 256);
    Total %= 20;

    Drops = Total / 10;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits10", 256);
    Total %= 10;

    Drops = Total / 5;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits5", 256);
    Total %= 5;
    
    Drops = Total;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits1", 256);
};

// Fires a projectile from the Player
function bool FireProjectile(str Type)
{
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0);
    fixed Pitch = GetActorPitch(0);
    fixed Angle = GetActorAngle(0);
    fixed XSpeed = Cos(Angle) * 16.0;
    fixed YSpeed = Sin(Angle) * 16.0;
    fixed ZSpeed = -Sin(Pitch) * 16.0;
    fixed FireHeight = GetActorViewHeight(0) * 0.8;
    int TID = UniqueTID();
    
    SpawnProjectile(0, Type, 0, 0, 0, 0, TID);
    SetActorVelocity(TID, XSpeed, YSpeed, ZSpeed, 0, 0);
    SetActorAngle(TID, Angle);
    SetActorPosition(TID, X, Y, Z + FireHeight, 0);
    Thing_ChangeTID(TID, 0);
    
    return true;
};

// Emits a Nova from the Player
function bool Nova(str Type, int Projectiles)
{
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0);
    fixed Pitch = GetActorPitch(0);
    fixed Angle = GetActorAngle(0);
    fixed XSpeed = Cos(Angle) * 16.0;
    fixed YSpeed = Sin(Angle) * 16.0;
    fixed ZSpeed = -Sin(Pitch) * 16.0;
    fixed FireHeight = GetActorViewHeight(0) * 0.8;
    int TID = UniqueTID();
    fixed AngleAdd;
    
    AngleAdd = 1.0 / Projectiles;
    
    for (int i = 0; i < Projectiles; i++)
    {
        XSpeed = Cos(Angle) * 16.0;
        YSpeed = Sin(Angle) * 16.0;
        ZSpeed = -Sin(Pitch) * 16.0;
        
        SpawnProjectile(0, Type, 0, 0, 0, 0, TID);
        SetActorVelocity(TID, XSpeed, YSpeed, ZSpeed, 0, 0);
        SetActorAngle(TID, Angle);
        SetActorPosition(TID, X, Y, Z + FireHeight, 0);
        Thing_ChangeTID(TID, 0);
        
        Angle += AngleAdd;
    };
    
    return true;
};

// Formats time into MM:SS for display with Print or HudMessage
function str FormatTime(int t)
{
    int Hours = t / 35 / 60 / 60;
    int Minutes = t / 35 / 60 % 60;
    int Seconds = t / 35 % 60;
    str Time = "";
    
    // Hours
    if (Hours > 0)
        Time = StrParam("%d:\n", Hours);
    
    // Minutes
    if (Hours > 0 && Minutes < 10)
        Time = StrParam("%s0%d:\n", Time, Minutes)
    else
        Time = StrParam("%s%d:\n", Time, Minutes);
    
    // Seconds
    if (Seconds < 10)
        Time = StrParam("%s0%d\n", Time, Seconds)
    else
        Time = StrParam("%s%d\n", Time, Seconds);
    
    return Time;
};

// Spawn an Aura on the given TID
function void SpawnAura(int TID, int Type, bool ForceFancy)
{
    fixed X = GetActorX(TID);
    fixed Y = GetActorY(TID);
    fixed Z = GetActorZ(TID);
    fixed Radius = GetActorPropertyFixed(TID, APROP_Radius);
    fixed Height = GetActorPropertyFixed(TID, APROP_Height);
    int Angle = GetActorAngle(TID) * 256;
    bool SpawnOK = false;
    bool IsPlayer = (ClassifyActor(TID) & ACTOR_PLAYER);
    int SimpleType = GetCVar("drpg_simple_auras");
    bool Simple = (IsPlayer ? (SimpleType == 1 || SimpleType == 3) : (SimpleType == 2 || SimpleType == 3));
    int AuraCount;
    
    // Calculate number of active Auras
    if (IsPlayer)
        for (int i = 0; i < AURA_MAX; i++)
            if (Player.Aura[i])
                AuraCount++;
    
    // Create rotation for simple Aura icons
    if (IsPlayer && Simple && AuraCount > 1)
    {
        if (Type == 10) // Shadow
            Z += 4.0 + Sin(Timer() / 64.0) * 4.0
        else
        {
            fixed Time = (fixed)Timer() + ((fixed)Type * 14.5);
            X += Sin(Time / 128.0) * 32.0;
            Y += Cos(Time / 128.0) * 32.0;
            Z += 4.0 + Sin(Timer() / 64.0) * 4.0;
        };
    };
    
    if (Type != 0 && Type != 10 && IsStealth(TID))
        return;
    
    if (GameType() == GAME_SINGLE_PLAYER)
    {
        if (CheckSight(Players(0).TID, TID, CSF_NOBLOCKALL))
            SpawnOK = true;
    }
    else
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            if (CheckSight(Players(i).TID, TID, CSF_NOBLOCKALL))
            {
                SpawnOK = true;
                break;
            };
        };
    };
    
    if (!SpawnOK)
        return;
    
    switch (Type)
    {
    case 0: // Friendly Monster
        if (!Simple)
            SpawnForced("DRPGFriendlyAura", X, Y, Z + 32.0, 0, Angle)
        else
            SpawnForced("DRPGFriendlyIndicator", X, Y, Z + Height + 8.0, 0, Angle);
        break;
    case 1: // Red Aura - Strength
        if (!Simple)
            SpawnForced("DRPGRedAura", X, Y, Z + Height / 2.0, AuraTID, Angle)
        else
            SpawnForced("DRPGRedAuraIndicator", X, Y, Z + Height + 8.0, 0, Angle);
        break;
    case 2: // Green Aura - Defense
        if (!Simple)
            SpawnForced("DRPGGreenAura", X, Y, Z + Height / 2.0, AuraTID, Angle)
        else
            SpawnForced("DRPGGreenAuraIndicator", X, Y, Z + Height + 8.0, 0, Angle);
        break;
    case 3: // White Aura - XP
        if (!Simple)
            SpawnForced("DRPGWhiteAura", X, Y, Z + Height / 2.0, AuraTID, Angle)
        else
            SpawnForced("DRPGWhiteAuraIndicator", X, Y, Z + Height + 8.0, 0, Angle);
        break;
    case 4: // Pink Aura - Vitality
        if (!Simple)
            SpawnForced("DRPGPinkAura", X, Y, Z + Height / 2.0, AuraTID, Angle)
        else
            SpawnForced("DRPGPinkAuraIndicator", X, Y, Z + Height + 8.0, 0, Angle);
        break;
    case 5: // Blue Aura - Energy
        if (!Simple)
            SpawnForced("DRPGCyanAura", X, Y, Z + Height / 2.0, AuraTID, Angle)
        else
            SpawnForced("DRPGCyanAuraIndicator", X, Y, Z + Height + 8.0, 0, Angle);
        break;
    case 6: // Purple Aura - Regeneration
        if (!Simple)
            SpawnForced("DRPGPurpleAura", X, Y, Z + Height / 2.0, AuraTID, Angle)
        else
            SpawnForced("DRPGPurpleAuraIndicator", X, Y, Z + Height + 8.0, 0, Angle);
        break;
    case 7: // Orange Aura - Agility
        if (!Simple)
            SpawnForced("DRPGOrangeAura", X, Y, Z + Height / 2.0, AuraTID, Angle)
        else
            SpawnForced("DRPGOrangeAuraIndicator", X, Y, Z + Height + 8.0, 0, Angle);
        break;
    case 8: // Dark Blue Aura - Capacity
        if (!Simple)
            SpawnForced("DRPGBlueAura", X, Y, Z + Height / 2.0, AuraTID, Angle)
        else
            SpawnForced("DRPGBlueAuraIndicator", X, Y, Z + Height + 8.0, 0, Angle);
        break;
    case 9: // Yellow Aura - Luck
        if (!Simple)
            SpawnForced("DRPGYellowAura", X, Y, Z + Height / 2.0, AuraTID, Angle)
        else
            SpawnForced("DRPGYellowAuraIndicator", X, Y, Z + Height + 8.0, 0, Angle);
        break;
    case 10: // Black Aura - Miniboss
        if (!Simple)
            SpawnForced("DRPGBlackAura", X, Y, Z + Height / 2.0, AuraTID, Angle)
        else
            SpawnForced("DRPGBlackAuraIndicator", X, Y, Z + Height + 8.0, 0, Angle);
        break;
    };
    
    // Pass Radius and Height to the Auras for DECORATE usage
    if (!Simple)
    {
        SetUserVariable(AuraTID, "user_radius", (int)Radius);
        SetUserVariable(AuraTID, "user_height", (int)Height);
    };
    
    // Remove the TID
    Thing_ChangeTID(AuraTID, 0);
};

// Returns whether a monster is in some form of stealth or not
function bool IsStealth(int tid)
{
    return
    (
        // Fuzzy
        GetActorProperty(tid, APROP_RenderStyle) == STYLE_Fuzzy ||
        GetActorProperty(tid, APROP_RenderStyle) == STYLE_OptFuzzy ||
        // Translucent
        (GetActorProperty(tid, APROP_RenderStyle) == STYLE_Translucent &&
            GetActorPropertyFixed(tid, APROP_Alpha) < 0.5) ||
        (GetActorProperty(tid, APROP_RenderStyle) == STYLE_TranslucentStencil &&
            GetActorPropertyFixed(tid, APROP_Alpha) < 0.5) ||
        (GetActorProperty(tid, APROP_RenderStyle) == STYLE_Add &&
            GetActorPropertyFixed(tid, APROP_Alpha) < 0.5) ||
        // Totally invisible
        GetActorProperty(tid, APROP_RenderStyle) == STYLE_None ||
        // Actor flags
        // These two cases are already handled by the RenderStyle checks above
        //CheckFlag(tid, "STEALTH") ||
        //CheckFlag(tid, "SHADOW") ||
        CheckFlag(tid, "INVISIBLE")
    );
};

// Return the amount of ammo corresponding to an ammo pickup
function int GetAmmoAmount(str Item)
{
    int Amount = 1;
    
    if (Item == "Clip")         Amount = 10;
    if (Item == "ClipBox")      Amount = 50;
    if (Item == "Shell")        Amount = 4;
    if (Item == "ShellBox")     Amount = 20;
    if (Item == "RocketAmmo")   Amount = 1;
    if (Item == "RocketBox")    Amount = 5;
    if (Item == "Cell")         Amount = 20;
    if (Item == "CellPack")     Amount = 100;
    
    return Amount;
};

// Calculates pay for the Rank Payout
function int CalculatePay(int PlayerNum)
{
    if (PlayerNum == 0) PlayerNum = PlayerNumber();
    return (int)(((((fixed)Players(PlayerNum).RankLevel + 1.0) * 10.0) + ((fixed)Players(PlayerNum).PayKills * ((fixed)Players(PlayerNum).RankLevel + 1.0))) * (1.0 + (fixed)Players(PlayerNum).PayBonus / 100.0));
};

function void DrawPay(int Amount)
{
    SetFont("BIGFONT");
    SetHudSize(0, 0, false);
    HudMessage("+%d\n", Amount, HUDMSG_FADEOUT, PAY_ID, CR_GOLD, -0.12, 0.09, 4.0, 2.0);
};

function void DrawBattery()
{
    fixed X = GetCVarFixed("drpg_aug_x");
    fixed Y = GetCVarFixed("drpg_aug_y");
    int HoldTime = (GetCVar("drpg_aug_showbattery") ? 0.05 : 3.0);
    int FadeTime = (GetCVar("drpg_aug_showbattery") ? 0.05 : 2.0);
    
    SetHudSize(640, 480, false);
    PrintSpriteFade("AUGBATT", BATTERY_ID, X + 0.4, Y + 0.4, HoldTime, FadeTime);
    SetFont("BIGFONT");
    HudMessage("%d%%\n", Player.Augs.Battery, HUDMSG_FADEOUT, BATTERY_ID + 1, CR_YELLOW, X + 24.0, Y - 10.0, HoldTime, FadeTime);
};

function void DrawItemGrid(int Type)
{
    // Coordinates
    fixed BaseX;
    fixed BaseY;
    fixed BoxX;
    fixed BoxY;
    fixed X;
    fixed Y;
    fixed IconX;
    fixed IconY;
    
    for (int i = 0; i < 6; i++)
    {
        // Reset base X
        BaseX = 0.0;
        
        for (int j = 0; j < 9; j++)
        {
            int Page = (Type == IG_LOCKER ? Player.LockerPage : Player.ShopPage);
            int BaseIndex = (Type == IG_LOCKER ? Player.LockerIndex : Player.ShopIndex);
            int Index = j + (i * 9);
            
            // Calculate offset
            if (BaseIndex >= 6 * 9)
                Index += (BaseIndex / (6 * 9)) * (6 * 9);
            
            ItemInfo ItemSpace *Item = &ItemData[Page][Index];
            str Icon = Item->Sprite.Name;
            str Name = Item->Name;
            int IconXOff = Item->Sprite.XOff;
            int IconYOff = Item->Sprite.YOff;
            int Held = CheckInventory(Item->Actor);
            int Stored = (Player.LockerGlobal ? GlobalLocker[Page][Index] : Player.Locker[Page][Index]);
            int Rank = Item->Rank;
            int Price = Item->Price;
            bool Unlocked = !((Rank > 0 && Player.RankLevel < Rank));
            bool CanBuy = !(Rank == -1);
            bool CanAfford = (CheckInventory("DRPGCredits") >= Price - Price * Player.ShopDiscount / 100);
            bool AutoSell = Player.AutoSell[Page][Index];
            
            // Stop if we're at the end of the list
            if (Index > ItemMax[Page] - 1) break;
            
            // Placeholder Icon
            if (StrLen(Icon) == 0)
                Icon = "SprNone";
            
            // Setup X and Y
            X = 26.0 + BaseX;
            Y = 50.0 + BaseY;
            BoxX = 48.0 + BaseX;
            BoxY = 72.0 + BaseY;
            IconX = 48.0 + BaseX;
            IconY = 72.0 + BaseY;
            IconX += IconXOff;
            IconY += IconYOff;
            
            // Amount
            if (Held > 0)
            {
                SetFont("BIGFONT");
                HudMessage("%d\n", Held, HUDMSG_PLAIN, 0, CR_GREEN, X + 44.2, Y + 44.2, 0.05);
            };
            if (Type == IG_LOCKER && Stored > 0)
            {
                SetFont("BIGFONT");
                HudMessage("%d\n", Stored, HUDMSG_PLAIN, 0, CR_YELLOW, X + 44.2, Y + 12.2, 0.05);
            };
            
            // Auto-Sell Icon
            if (Type == IG_STORE && Player.AutoSell[Page][Index])
                PrintSpritePulse("SELLICN", 0, X - 2.0 + 0.1, Y + 0.1, 0.75, 128.0, 0.25, false);
            
            // Icon
            SetHudClipRect(X, Y, 44, 44);
            if (BaseIndex == Index)
            {
                if (Unlocked || Type == IG_LOCKER)
                    PrintSpritePulse(Icon, 0, IconX, IconY, 0.75, 32.0, 0.25)
                else
                    PrintSpritePulse(Icon, 0, IconX, IconY, 0.25, 32.0, 0.25);
            }
            else
            {
                if (Unlocked || Type == IG_LOCKER)
                    PrintSprite(Icon, 0, IconX, IconY, 0.05)
                else
                    PrintSpriteAlpha(Icon, 0, IconX, IconY, 0.05, 0.25);
            };
            SetHudClipRect(0, 0, 0, 0);
            
            // Box
            if (BaseIndex == Index)
                if ((!CanAfford || !Unlocked || !CanBuy) && Type == IG_STORE)
                    PrintSprite("ItemBoxR", 0, BoxX, BoxY, 0.05)
                else
                    PrintSprite("ItemBoxH", 0, BoxX, BoxY, 0.05);
            PrintSprite("ItemBoxB", 0, BoxX, BoxY, 0.05);
            
            // Item Name
            if (BaseIndex == Index)
            {
                SetFont("BIGFONT");
                HudMessage("%s\n", Name, HUDMSG_PLAIN, 0, ((Type == IG_STORE && CanAfford) || Type == IG_LOCKER ? CR_WHITE : CR_RED), 24.1, 344.1, 0.05);
            };
            
            // Increment X
            BaseX += 48.0;
        };
        
        // Increment Y
        BaseY += 48.0;
    };
};

function void DrawBar(str Fill, int X, int Y, int Amount, bool Pulse)
{
    for (int i = 0; i < Amount; i++)
        if (Pulse)
            PrintSpriteAlpha(Fill, 0, X + 0.1 + (i * 1.0), Y, 0.05, 0.75 + Sin((Timer() + i) / 32.0) * 0.25)
        else
            PrintSprite(Fill, 0, X + 0.1 + (i * 1.0), Y, 0.05);
};

// Computes n-th power of x
function int Pow(int x, int n)
{
    int y = 1;
    while (n-- > 0) y *= x;
    return y;
};

// Return the absolute value of a negative integer
function int Abs(int x)
{
    if (x < 0)
        return -x;

    return x;
};

// Rounds a fixed to the nearest integer
function int Round(fixed fixedNumber)
{
    return (int)(fixedNumber += 0.5);
};

// Gets the distance between two TIDs
function fixed Distance(int TID1, int TID2)
{
    fixed X = GetActorX(TID1) - GetActorX(TID2);
    fixed Y = GetActorY(TID1) - GetActorY(TID2);
    fixed Z = GetActorZ(TID1) - GetActorZ(TID2);
    
    return VectorLength(VectorLength(X, Y), Z);
};

// Gets the distance between two points on the HUD
function fixed DistanceScreen(int X1, int Y1, int X2, int Y2)
{
    fixed X = X1 - X2;
    fixed Y = Y1 - Y2;
    
    return VectorLength(X, Y);
};

function bool StartsWith(str InString, str Prefix, bool NoCase)
{
    if (NoCase)
        return !StrICmp(InString, Prefix, StrLen(Prefix));
    return !StrCmp(InString, Prefix, StrLen(Prefix));
};

function bool EndsWith(str InString, str Suffix, bool NoCase)
{
    if (StrLen(InString) < StrLen(Suffix))
        return false;
    
    if (NoCase)
        return !StrICmp(StrRight(InString, StrLen(Suffix)), Suffix);
    return !StrCmp(StrRight(InString, StrLen(Suffix)), Suffix);
};

function bool Contains(str InString, str SubString, bool NoCase)
{
    int TargLen = StrLen(InString);
    int SubLen = StrLen(SubString);
    
    if (TargLen < SubLen)
        return false;
    
    for (int i = 0; i < TargLen - SubLen; i++)
    {
        str Part = StrMid(InString, i, SubLen);
        if ((!NoCase && !StrCmp(Part, SubString)) || (NoCase && !StrICmp(Part, SubString)))
            return true;
    };
    
    return false;
};

function bool IsPlayerMoving()
{
    return (GetPlayerInput(PlayerNumber(), MODINPUT_FORWARDMOVE) ||
            GetPlayerInput(PlayerNumber(), MODINPUT_SIDEMOVE) ||
            GetPlayerInput(PlayerNumber(), MODINPUT_UPMOVE));
};

function bool DropPlayerItem(str Item)
{
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0) + Cos(Angle);
    fixed Y = GetActorY(0) + Sin(Angle);
    fixed Z = GetActorZ(0) + 16.0;
    fixed XSpeed = Cos(Angle) * 4.0;
    fixed YSpeed = Sin(Angle) * 4.0;
    int TID = UniqueTID();
    bool SpawnOK = Spawn(Item, X, Y, Z, TID, Angle);
    bool SightOK = CheckSight(TID, 0, 0);
    
    // Remove the item if it fails the sight check
    if (!SightOK)
        Thing_Remove(TID);
    
    // Apply Velocity
    if (SpawnOK && SightOK)
        SetActorVelocity(TID, XSpeed, YSpeed, 0, false, false);
    
    return (SpawnOK && SightOK);
};

function int DropMonsterItem(int Killer, int TID, str Item, int Chance, fixed XAdd, fixed YAdd, fixed ZAdd)
{
    // if this is an invalid killer, return
    if (!(Killer > -1)) return 0;
    
    // Chance
    if (!(Random(1, 256) <= Chance)) return 0;
    
    fixed Angle = GetActorAngle(TID);
    fixed X = GetActorX(TID) + XAdd;
    fixed Y = GetActorY(TID) + YAdd;
    fixed Z = GetActorZ(TID) + (GetActorPropertyFixed(0, APROP_Height) / 2.0) + ZAdd;
    fixed XSpeed = GetCVarFixed("drpg_monster_dropdist");
    fixed YSpeed = GetCVarFixed("drpg_monster_dropdist");
    fixed ZSpeed = 8.0;
    int ItemTID = UniqueTID();
    bool Success = false;
    
    // Spawn the Item
    Success = SpawnForced(Item, X, Y, Z, ItemTID, Angle);
    
    // Spawn successful
    if (Success)
    {
        // Set Velocity
        SetActorVelocity(ItemTID, RandomFixed(-XSpeed, XSpeed), RandomFixed(-YSpeed, YSpeed), ZSpeed, false, false);
        
        // Array has grown too big, resize it
        if (Players(Killer).DropTID.Position == Players(Killer).DropTID.Size)
            ArrayResize(&Players(Killer).DropTID);
        
        // Add item's TID to drop array
        ((int *)Players(Killer).DropTID.Data)[Players(Killer).DropTID.Position++] = ItemTID;
    };
    
    return ItemTID;
};

function bool HaveStatusEffect()
{
    for (int i = 0; i < SE_MAX; i++)
        if (Player.StatusType[i])
            return true;
    
    return false;
};

function int FindPlayerID(int TID)
{
    for (int i = 0; i < MAX_PLAYERS; i++)
        if (Players(i).TID == TID)
        {
            return i;
            break;
        };
    
    return -1;
};

function bool CheckInput(int Key, int State)
{
    int Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
    int OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
    
    if (State == KEY_PRESSED)
        return (Buttons & Key && !(Buttons & Key));
    if (State == KEY_ONLYPRESSED)
        return (Buttons == Key && Buttons != Key);
    if (State == KEY_DOWN)
        return (Buttons & Key);
    if (State == KEY_UP)
        return (OldButtons & Key);
};

// This shit doesn't work at all because ZDoom is fucking stupid or something, fuck if I know
function void LogMessage(str Message, int Level)
{
    bool DebugMode = (ActivatorTID() == Player.TID ? GetCVar("drpg_debug") : GetUserCVar(PlayerNumber(), "drpg_debug"));
    
    if (Level == LOG_DEBUG)
        Message = StrParam("\cdDEBUG: \c-%s\n", Message);
    if (Level == LOG_WARNING)
        Message = StrParam("\ciWARNING: \c-%s\n", Message);
    if (Level == LOG_ERROR)
        Message = StrParam("\cgERROR: \c-%s\n", Message);
    
    // Don't log the message if the caller isn't in Debug Mode
    if (Level == LOG_DEBUG && !DebugMode)
        return;
    
    Log("%s\n", Message);
};

acscript void CheckArmorStats()
{
    Log("\c[Orange]-- ARMOR STATS --\n");
    Log("\c[Green]Class name: \c[White]%s\n", GetArmorInfoString(ARMORINFO_CLASSNAME));
    Log("\c[Green]Durability: \c[LightBlue]%i%%\n", GetArmorInfo(ARMORINFO_SAVEAMOUNT));
    Log("\c[Green]Protection: \c[Yellow]%k%%\n", GetArmorInfoFixed(ARMORINFO_SAVEPERCENT) * 100.0);
    Log("\c[Green]Max Absorb: \c[Grey]%i%%\n", GetArmorInfo(ARMORINFO_MAXABSORB));
    Log("\c[Green]Max Full Absorb: \c[Brick]%i%%\n", GetArmorInfo(ARMORINFO_MAXFULLABSORB));
};

// This function is specifically to avoid dividing by zero in the event that that can happen.
function int CalcPercent(int Current, int Max)
{
    if (Max == 0)
        return 100;
    return Current * 100 / Max;
};

// Dynamic Arrays
// --------------------------------------------------

function void ArrayCreate(DynamicArray *Array, char[5] Name, int InitSize, int ItemSize)
{
    if (Array->Data != nullptr)
        ArrayDestroy(Array);
    
    Array->Name = Name;
    
    if (GetCVar("drpg_debug"))
        Log("\cdDynamicArray: Allocating \cj%s\n", Array->Name);
    
    Array->Position = 0;
    Array->Size = InitSize;
    Array->ItemSize = ItemSize;
    Array->Data = Z_Malloc(Array->ItemSize * Array->Size, PU_STATIC, NULL);
    
    if (!Array->Data)
    {
        Log("\cgERROR: \c-Could not allocate space for array \cj%s\n", Array->Name);
        return;
    };
    
    if (GetCVar("drpg_debug"))
        Log("\cdDynamicArray: \cj%s\cd @ %p\n", Array->Name, Array->Data);
    
    memset(Array->Data, 0xAAAAAAAA, Array->Size * Array->ItemSize);
};

function void ArrayResize(DynamicArray *Array)
{
    if (Array->Data == nullptr)
    {
        Log("\cgERROR: \c-Tried to resize destroyed array \cj%s\n", Array->Name);
        return;
    };
    
    int OldSize = Array->Size;
    
    Array->Size *= 2;
    void *tmp = Z_Realloc(Array->Data, Array->ItemSize * Array->Size, PU_STATIC, NULL);
    
    if (!tmp)
    {
        Z_Free(Array->Data);
        Log("\cgERROR: \c-Cannot resize dynamic array \cj%s\n", Array->Name);
        return;
    };
    
    if (GetCVar("drpg_debug"))
        Log("\cdDynamicArray: Resizing array \cj%s\cd @ %p to \cj%d\cd elements\n", Array->Name, Array->Data, Array->Size);
    
    Array->Data = tmp;
    
    memset((char *)Array->Data + (Array->ItemSize * OldSize), 0xAAAAAAAA, (Array->Size * Array->ItemSize) - (Array->ItemSize * OldSize));
};

function void ArrayDestroy(DynamicArray *Array)
{
    if (GetCVar("drpg_debug"))
        Log("\cdDynamicArray: Destroying array \cj%s\cd @ %p\n", Array->Name, Array->Data);
    
    Z_Free(Array->Data);
    
    Array->Position = 0;
    Array->Size = 0;
    Array->ItemSize = 0;
    Array->Data = nullptr;
};

function void ArrayDump(DynamicArray *Array)
{
    Log("\ciDynamicArray \cj%s\c- @ %p\n", Array->Name, Array->Data);
    Log("\cd* Array size: \cj%d\n", Array->Size);
    Log("\cd* Item bytesize: \cj%d\n", Array->ItemSize);
    Log("\cd* End Position: \cj%d\n", Array->Position);
    Log("\n");
    
    Log("\ciItem data:\n");
    
    for (int i = 0; i < Array->Size; i++)
    {
        str DataString = StrParam ("  %X: \n", i);
        for (int b = 0; b < Array->ItemSize; b++)
            DataString = StrParam ("%s%X \n", DataString, (char)((char *)Array->Data)[Array->ItemSize * i + b]);
        
        if (i >= Array->Position)
            DataString = StrParam ("%s\cj(\cgUnused\cj)\n", DataString);
        
        Log("%s\n", DataString);
    };
};
