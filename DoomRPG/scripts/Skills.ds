#include "RPG.dh"

#include "Arena.dh"
#include "Map.dh"
#include "Menu.dh"
#include "Monsters.dh"
#include "Outpost.dh"
#include "Shield.dh"
#include "Shop.dh"
#include "Skills.dh"
#include "Stats.dh"
#include "Utils.dh"

static Skill[MAX_PLAYERS][MAX_CATEGORIES][MAX_SKILLS] _SkillData;

bool Overdrive;
int BulletTimeTimer;
int ForceFieldTID = 1998;

int[MAX_CATEGORIES] SkillCategoryMax =
{
    5; 9; 9; 5; 17; 8;
};

AddressSpace MapArray SkillSpace;
SkillSpace Skill[MAX_CATEGORIES][MAX_SKILLS] SkillDataBase =
{
    // Healing/Support
    {
        {
            "Heal"; 25; 4; Heal;
            {
                "Recover 25% HP";
                "Recover 50% HP";
                "Recover 75% HP\nHeals Status Effects";
                "Recover 100% HP\nHeals Status Effects";
            };
        };
        {
            "Heal Summons"; 100; 1; HealSummons;
            {
                "Summons recover all of their HP";
            };
        };
        {
            "Heal Team"; 50; 4; HealTeam;
            {
                "Heals you and your teammates for 25% HP";
                "Heals you and your teammates for 50% HP";
                "Heals you and your teammates for 75% HP\nHeals you and your teammmates Status Effects";
                "Heals you and your teammates for all HP\nHeals you and your teammmates Status Effects";
            };
        };
        {
            "Decontamination"; 100; 4; Decontaminate;
            {
                "Remove 25% of your Toxicity";
                "Remove 50% of your Toxicity";
                "Remove 75% of your Toxicity";
                "Remove all of your Toxicity";
            };
        };
        {
            "Repair Armor"; 50; 4; Repair;
            {
                "Repair 25% of your Armor";
                "Repair 50% of your Armor";
                "Repair 75% of your Armor";
                "Repair all of your Armor";
            };
        };
    };
    
    // Powerups
    {
        {
            "Invulnerability"; 250; 2; Powerup;
            {
                "Invulnerability to all attacks\n\cd(30 Sec)";
                "Invulnerability to all attacks\nProjectiles are reflected back at enemies\n\cd(30 Sec)";
            };
        };
        {
            "Invisibility"; 100; 2; Powerup;
            {
                "Makes you invisible to enemies\n\cd(30 sec)";
                "Makes you invisible to enemies\nSome projectiles pass through you\n\cd(30 sec)";
            };
        };
        {
            "Time Freeze"; 200; 2; BulletTime;
            {
                "Stutter Time";
                "Freeze Time";
            };
        };
        {
            "Iron Feet"; 100; 1; Powerup;
            {
                "Protection from Damage Floors";
            };
        };
        {
            "Night Vision"; 200; 1; Powerup;
            {
                "Allows you to see in the dark";
            };
        };
        {
            "Berserk"; 200; 1; Powerup;
            {
                "Full Health\nIncreased Melee Damage";
            };
        };
        {
            "Mental Mapping"; 200; 1; Powerup;
            {
                "Full Map\nItem/Enemy Tracking";
            };
        };
        {
            "Weapon Drop"; 200; 7; DropWeapon;
            {
                "Drops a Weapon at your location\n\cjPistol";
                "Drops a Weapon at your location\n\cjShotgun";
                "Drops a Weapon at your location\n\cjSuper Shotgun";
                "Drops a Weapon at your location\n\cjChaingun";
                "Drops a Weapon at your location\n\cjRocket Launcher";
                "Drops a Weapon at your location\n\cjPlasma Rifle";
                "Drops a Weapon at your location\n\cjBFG9000";
            };
        };
        {
            "Ammo Drop"; 50; 3; DropAmmo;
            {
                "Drops a Small Backpack full of ammo at your location";
                "Drops a Backpack full of ammo at your location";
                "Drops a Large Backpack full of ammo at your location";
            };
        };
    };
    
    // Auras
    {
        {
            "Red Aura"; 100; 6; UseAura;
            {
                "1.25x Damage";
                "1.5x Damage";
                "1.75x Damage";
                "2x Damage";
                "3x Damage";
                "4x Damage";
            };
        };
        {
            "Green Aura"; 100; 3; UseAura;
            {
                "-25% Damage Taken";
                "-50% Damage Taken";
                "-75% Damage Taken\nDamage Floor Protection";
            };
        };
        {
            "White Aura"; 100; 5; UseAura;
            {
                "Double Combo";
                "Double Combo\nConstant Combo";
                "Double Combo\nConstant Combo\n2x XP Per Kill";
                "Double Combo\nConstant Combo\n2x XP Per Kill\nSlow XP Gain";
                "Double Combo\nConstant Combo\n2x XP Per Kill\nFast XP Gain";
            };
        };
        {
            "Pink Aura"; 100; 2; UseAura;
            {
                "Immune to Status Effects";
                "Immune to Status Effects\nDrain Enemy HP";
            };
        };
        {
            "Blue Aura"; 100; 3; UseAura;
            {
                "25% Skill Cost Reduction";
                "50% Skill Cost Reduction";
                "75% Skill Cost Reduction";
            };
        };
        {
            "Purple Aura"; 100; 4; UseAura;
            {
                "2x HP/EP Regen Amount";
                "3x HP/EP Regen Amount";
                "4x HP/EP Regen Amount";
                "4x HP/EP Regen Amount\n-2x HP/EP Regen Timers";
            };
        };
        {
            "Orange Aura"; 100; 3; UseAura;
            {
                "Double Movement Speed";
                "Double Movement Speed\nDouble Jump Height";
                "Double Movement Speed\nDouble Jump Height\nDouble Firing Speed";
            };
        };
        {
            "Dark Blue Aura"; 100; 7; UseAura;
            {
                "Clip Regen";
                "Clip Regen\nShell Regen";
                "Clip Regen\nShell Regen\nRocket Regen";
                "Clip Regen\nShell Regen\nRocket Regen\nCell Regen";
                "Clip Regen\nShell Regen\nRocket Regen\nCell Regen\n2x Regen Speed";
                "Clip Regen\nShell Regen\nRocket Regen\nCell Regen\n4x Regen Speed";
                "Clip Regen\nShell Regen\nRocket Regen\nCell Regen\n4x Regen Speed\nInfinite Ammo";
            };
        };
        {
            "Yellow Aura"; 100; 5; UseAura;
            {
                "Slow Money Generation\n1.25x Drop Chances";
                "Medium Money Generation\n1.5x Drop Chances";
                "Fast Money Generation\n2x Drop Chances";
                "Very Fast Money Generation\n4x Drop Chances";
                "Mega Money Generation\n8x Drop Chances";
            };
        };
    };
    
    // Attacks
    {
        {
            "Weaken"; 200; 2; Weaken;
            {
                "Weakens an enemy, halving their stats";
                "Weakens an enemy, halving their stats and destroying their Aura";
            };
        };
        {
            "Translocate"; 50; 1; Translocate;
            {
                "Teleports a monster to the beginning of the level";
            };
        };
        {
            "Repulsion"; 50; 4; Repulse;
            {
                "A small blast which slightly pushes enemies away";
                "A blast which pushes enemies away";
                "A large blast which greatly pushes enemies away";
                "A huge blast which launches enemies away";
            };
        };
        {
            "Aura Steal"; 200; 1; AuraSteal;
            {
                "Steals an enemies Aura, taking it from them and giving it to you\nTime based on their Level";
            };
        };
        {
            "Soul Steal"; 100; 10; SoulSteal;
            {
                "Steal 10% of the target's maximum HP\nIf the enemy dies, they will drop their Soul\n\cuDoes not work on Shadow enemies";
                "Steal 20% of the target's maximum HP\nIf the enemy dies, they will drop their Soul\n\cuDoes not work on Shadow enemies";
                "Steal 30% of the target's maximum HP\nIf the enemy dies, they will drop their Soul\n\cuDoes not work on Shadow enemies";
                "Steal 40% of the target's maximum HP\nIf the enemy dies, they will drop their Soul\n\cuDoes not work on Shadow enemies";
                "Steal 50% of the target's maximum HP\nIf the enemy dies, they will drop their Soul\n\cuDoes not work on Shadow enemies";
                "Steal 60% of the target's maximum HP\nIf the enemy dies, they will drop their Soul\n\cuDoes not work on Shadow enemies";
                "Steal 70% of the target's maximum HP\nIf the enemy dies, they will drop their Soul\n\cuDoes not work on Shadow enemies";
                "Steal 80% of the target's maximum HP\nIf the enemy dies, they will drop their Soul\n\cuDoes not work on Shadow enemies";
                "Steal 90% of the target's maximum HP\nIf the enemy dies, they will drop their Soul\n\cuDoes not work on Shadow enemies";
                "Steal 100% of the target's maximum HP\nIf the enemy dies, they will drop their Soul\n\cuDoes not work on Shadow enemies";
            };
        };
    };
    
    // Summons
    {
        {
            "Summon Marine"; 100; 7; Summon;
            {
                "Summons a Marine\n\cjPistol";
                "Summons a Marine\n\cjShotgun";
                "Summons a Marine\n\cjSuper Shotgun";
                "Summons a Marine\n\cjChaingun";
                "Summons a Marine\n\cjRocket Launcher";
                "Summons a Marine\n\cjPlasma Rifle";
                "Summons a Marine\n\cjBFG 9000";
            };
        };
        {
            "Summon Zombieman"; 25; 1; Summon;
            {
                "Summons a Zombieman";
            };
        };
        {
            "Summon Shotgun Guy"; 50; 1; Summon;
            {
                "Summons a Shotgun Guy";
            };
        };
        {
            "Summon Chaingun Guy"; 75; 1; Summon;
            {
                "Summons a Chaingun Guy";
            };
        };
        {
            "Summon Imp"; 75; 1; Summon;
            {
                "Summons a Imp";
            };
        };
        {
            "Summon Demon"; 75; 1; Summon;
            {
                "Summons a Demon";
            };
        };
        {
            "Summon Cacodemon"; 100; 1; Summon;
            {
                "Summons a Cacodemon";
            };
        };
        {
            "Summon Hell Knight"; 150; 1; Summon;
            {
                "Summons a Hell Knight";
            };
        };
        {
            "Summon Baron of Hell"; 200; 1; Summon;
            {
                "Summons a Baron of Hell";
            };
        };
        {
            "Summon Lost Soul"; 100; 1; Summon;
            {
                "Summons a Lost Soul";
            };
        };
        {
            "Summon Pain Elemental"; 500; 1; Summon;
            {
                "Summons a Pain Elemental";
            };
        };
        {
            "Summon Revenant"; 500; 1; Summon;
            {
                "Summons a Revenant";
            };
        };
        {
            "Summon Mancubus"; 500; 1; Summon;
            {
                "Summons a Mancubus";
            };
        };
        {
            "Summon Arachnotron"; 500; 1; Summon;
            {
                "Summons a Arachnotron";
            };
        };
        {
            "Summon Arch-Vile"; 750; 1; Summon;
            {
                "Summons a Arch-Vile";
            };
        };
        {
            "Summon Cyberdemon"; 1000; 1; Summon;
            {
                "Summons a Cyberdemon";
            };
        };
        {
            "Summon Spider Mastermind"; 1000; 1; Summon;
            {
                "Summons a Spider Mastermind";
            };
        };
    };
    
    // Utility
    {
        {
            "Breakdown Armor"; 250; 1; BreakdownArmor;
            {
                "Breaks down your current Armor into Credits";
            };
        };
        {
            "Force Wall"; 100; 2; ForceWall;
            {
                "Creates a small force wall in front of you to reflect projectiles";
                "Creates a large force wall in front of you to reflect projectiles";
            };
        };
        {
            "Rally"; 0; 1; Rally;
            {
                "Teleports your summoned monsters to you";
            };
        };
        {
            "Unsummon"; 0; 2; Unsummon;
            {
                "Banishes all of the friendly creatures under your control";
                "Banishes all of the friendly creatures under your control\nEach creature banished restores\n\cn25 EP";
            };
        };
        {
            "Recall"; 25; 1; Recall;
            {
                "Brings you to the beginning of the level";
            };
        };
        {
            "Magnetize"; 100; 1; Magnetize;
            {
                "Pulls dropped items to you";
            };
        };
        {
            "Wireless Locker"; 0; 16; WirelessLocker;
            {
                "Access the Locker System Wirelessly\n";
                "Access the Locker System Wirelessly\n\cd5% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd10% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd15% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd20% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd25% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd30% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd35% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd40% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd45% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd50% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd55% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd60% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd65% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd70% Wireless Efficiency";
                "Access the Locker System Wirelessly\n\cd75% Wireless Efficiency";
            };
        };
        {
            "Transport"; 0; 1; Transport;
            {
                "Brings you to the UAC Outpost\nUse in Outpost to return to current level";
            };
        };
    };
};

function void InitSkills()
{
    for (int i = 0; i < MAX_CATEGORIES; i++)
        for (int j = 0; j < MAX_SKILLS; j++)
        {
            SkillPtr SkillIter = &SkillDataBase[i][j];
            
            Skills[i][j].Name = SkillIter->Name;
            Skills[i][j].Cost = SkillIter->Cost;
            Skills[i][j].MaxLevel = SkillIter->MaxLevel;
            Skills[i][j].Description = SkillIter->Description;
            Skills[i][j].Use = SkillIter->Use;
        };
};

function void BuildSkillData()
{
    // Transport should always be known
    Skills[MAX_CATEGORIES - 1][SkillCategoryMax[MAX_CATEGORIES - 1] - 1].Level = 1;
    Skills[MAX_CATEGORIES - 1][SkillCategoryMax[MAX_CATEGORIES - 1] - 1].CurrentLevel = 1;
    
    // DoomRL Compatibility
    if (GetCVar("drpg_ext_doomrl"))
    {
        // Add an extra level to the Ammo Drop to drop Supply Crates
        Skills[1][8].MaxLevel = 4;
        Skills[1][8].Description[3] = "Drops a Large Backpack full of ammo at your location\nDrops a Supply Crate at your location";
        
        // DoomRL Marines use slightly different weapons
        Skills[4][0].Description[2] = "Summons a Marine\n\cjDouble Shotgun";
        Skills[4][0].Description[3] = "Summons a Marine\n\cjBattle Rifle";
        
        // Summoning Skills - Names
        Skills[4][1].Name = "Summon Former Human";
        Skills[4][2].Name = "Summon Former Sergeant";
        Skills[4][3].Name = "Summon Former Commando";
        
        // Summoning Skills - Levels
        Skills[4][1].MaxLevel = 3;
        Skills[4][2].MaxLevel = 2;
        Skills[4][3].MaxLevel = 3;
        Skills[4][4].MaxLevel = 3;
        Skills[4][5].MaxLevel = 6;
        Skills[4][6].MaxLevel = 2;
        Skills[4][7].MaxLevel = 3;
        Skills[4][8].MaxLevel = 3;
        Skills[4][9].MaxLevel = 3;
        Skills[4][10].MaxLevel = 2;
        Skills[4][11].MaxLevel = 3;
        Skills[4][12].MaxLevel = 3;
        Skills[4][13].MaxLevel = 3;
        Skills[4][14].MaxLevel = 2;
        Skills[4][15].MaxLevel = 2;
        Skills[4][16].MaxLevel = 2;
        
        // Summoning Skills - Descriptions
        Skills[4][1].Description[0] = "Summons a Former Human";
        Skills[4][1].Description[1] = "Summons an Elite Human";
        Skills[4][1].Description[2] = "Summons a Former Human Captain";
        Skills[4][2].Description[0] = "Summons a Former Sergeant";
        Skills[4][2].Description[1] = "Summons an Elite Sergeant";
        Skills[4][3].Description[0] = "Summons a Former Commando";
        Skills[4][3].Description[1] = "Summons an Elite Commando";
        Skills[4][3].Description[2] = "Summons an Elite Human Captain";
        Skills[4][4].Description[1] = "Summons a Nightmare Imp";
        Skills[4][4].Description[2] = "Summons a Cyber-Imp";
        Skills[4][5].Description[1] = "Summons a Spectre";
        Skills[4][5].Description[2] = "Summons a Nightmare Demon";
        Skills[4][5].Description[3] = "Summons a Nightmare Spectre";
        Skills[4][5].Description[4] = "Summons a Mech-Demon";
        Skills[4][5].Description[5] = "Summons a Mechtre";
        Skills[4][6].Description[1] = "Summons a Nightmare Cacodemon";
        Skills[4][7].Description[1] = "Summons a Nightmare Knight";
        Skills[4][7].Description[2] = "Summons a Cybruiser";
        Skills[4][8].Description[1] = "Summons a Baron of Nightmares";
        Skills[4][8].Description[2] = "Summons a Techno-Lord";
        Skills[4][9].Description[1] = "Summons a Nightmare Soul";
        Skills[4][9].Description[2] = "Summons a Hellmine";
        Skills[4][10].Description[1] = "Summons a Nightmare Elemental";
        Skills[4][11].Description[1] = "Summons a Nightmare Revenant";
        Skills[4][11].Description[2] = "Summons a Heavy Revenant";
        Skills[4][12].Description[1] = "Summons a Nightmare Mancubus";
        Skills[4][12].Description[2] = "Summons a Volacubus";
        Skills[4][13].Description[1] = "Summons a Nightmare Arachnotron";
        Skills[4][13].Description[2] = "Summons a Arachnsentinel";
        Skills[4][14].Description[1] = "Summons a Nightmare Arch-Vile";
        Skills[4][15].Description[1] = "Summons a Nightmare Cyberdemon";
        Skills[4][16].Description[1] = "Summons a Spider Overmind";
    };
    
    // Icons
    for (int i = 0; i < MAX_CATEGORIES; i++)
        for (int j = 0; j < MAX_SKILLS; j++)
            Skills[i][j].Icon = StrParam("SKIL%d_%d\n", i + 1, j + 1);
};

// Skill Wheel
script void SkillWheel() enter
{
    Start:
    
    int Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
    int OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
    int Selected = -1;
    int LastSelected = -1;
    int Radius = 96;
    int CurrentRadius = 0;
    Skill *CurrentSkill;
    
    // Open the wheel
    if (Buttons & BT_USER1 && !((Player.InMenu && Player.Menu != 3) || Player.InShop || Player.OutpostMenu > 0))
    {
        ActivatorSound("menu/click", 127);
        Player.SkillWheelOpen = true;
    };
    
    // Wheel Loop
    while (Player.SkillWheelOpen)
    {
        SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
        
        // Check Input
        Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
        OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
        
        // Check for release
        if (!(Buttons & BT_USER1) && !(Buttons & BT_SPEED))
        {
            if (Selected != -1)
            {
                if (Player.InMenu && Player.Menu == 3)
                {
                    Player.SkillCategory[Selected] = Player.SkillPage;
                    Player.SkillIndex[Selected] = Player.MenuIndex;
                }
                else
                    Player.SkillSelected = Selected;
            };
            
            SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
            CurrentRadius = Radius;
            Player.SkillWheelOpen = false;
        };
        
        // Selection
        fixed MouseX = -GetPlayerInputFixed(PlayerNumber(), INPUT_YAW) * 1.2;
        fixed MouseY = GetPlayerInputFixed(PlayerNumber(), INPUT_PITCH);
        if (CurrentRadius >= Radius)
        {
            if (Buttons == (BT_USER1 | BT_FORWARD) && Selected != 0)
                Selected = 0
            else if (Buttons == (BT_USER1 | BT_FORWARD | BT_MOVERIGHT) && Selected != 1)
            {
                Selected = 1;
                Delay(5);
            }
            else if (Buttons == (BT_USER1 | BT_MOVERIGHT) && Selected != 2)
                Selected = 2
            else if (Buttons == (BT_USER1 | BT_MOVERIGHT | BT_BACK) && Selected != 3)
            {
                Selected = 3;
                Delay(5);
            }
            else if (Buttons == (BT_USER1 | BT_BACK) && Selected != 4)
                Selected = 4
            else if (Buttons == (BT_USER1 | BT_BACK | BT_MOVELEFT) && Selected != 5)
            {
                Selected = 5;
                Delay(5);
            }
            else if (Buttons == (BT_USER1 | BT_MOVELEFT) && Selected != 6)
                Selected = 6
            else if (Buttons == (BT_USER1 | BT_MOVELEFT | BT_FORWARD) && Selected != 7)
            {
                Selected = 7;
                Delay(5);
            }
            // There used to be non-working stuff here, but I fixed it to be working. -Kate
            else if ((FixedSqrt(MouseX * MouseX + MouseY * MouseY)) > 0.02)
            {
                if (VectorAngle(MouseX, MouseY) > 0.1875 && VectorAngle(MouseX, MouseY) < 0.3125)
                    Selected = 0
                else if (VectorAngle(MouseX, MouseY) > 0.0625 && VectorAngle(MouseX, MouseY) < 0.1875)
                    Selected = 1
                else if (VectorAngle(MouseX, MouseY) >= 0 && VectorAngle(MouseX, MouseY) < 0.0625)
                    Selected = 2
                else if (VectorAngle(MouseX, MouseY) <= 1 && VectorAngle(MouseX, MouseY) > 0.9375)
                    Selected = 2
                else if (VectorAngle(MouseX, MouseY) > 0.8125 && VectorAngle(MouseX, MouseY) < 0.9375)
                    Selected = 3
                else if (VectorAngle(MouseX, MouseY) > 0.6875 && VectorAngle(MouseX, MouseY) < 0.8125)
                    Selected = 4
                else if (VectorAngle(MouseX, MouseY) > 0.5625 && VectorAngle(MouseX, MouseY) < 0.6875)
                    Selected = 5
                else if (VectorAngle(MouseX, MouseY) > 0.4375 && VectorAngle(MouseX, MouseY) < 0.5625)
                    Selected = 6
                else if (VectorAngle(MouseX, MouseY) > 0.3125 && VectorAngle(MouseX, MouseY) < 0.4375)
                    Selected = 7;
            };
            // else
               // Selected = -1;
        };
        
        // Extra Input Handling
        if (Buttons & BT_SPEED && Selected != -1)
        {
            Skill *CurrentSkill = &Skills[Player.SkillCategory[Selected]][Player.SkillIndex[Selected]];
            
            // Decrease selected skill level
            if (Buttons & BT_MOVELEFT && !(OldButtons & BT_MOVELEFT) && CurrentSkill->CurrentLevel > 1)
            {
                CurrentSkill->CurrentLevel--;
                AmbientSound("menu/move", 127);
            };
            
            // Increase selected skill level
            if (Buttons & BT_MOVERIGHT && !(OldButtons & BT_MOVERIGHT) && CurrentSkill->CurrentLevel < CurrentSkill->Level)
            {
                CurrentSkill->CurrentLevel++;
                AmbientSound("menu/move", 127);
            };
            
            // Clear Skill
            if (Buttons & BT_USE)
            {
                Player.SkillCategory[Selected] = -1;
                Player.SkillIndex[Selected] = -1;
                AmbientSound("menu/move", 127);
            };
        };
        
        // Set Skill
        if (Selected >= 0 && Player.SkillCategory[Selected] != -1 && Player.SkillIndex[Selected] != -1)
            CurrentSkill = &Skills[Player.SkillCategory[Selected]][Player.SkillIndex[Selected]]
        else
            CurrentSkill = nullptr;
        
        // Play sound
        if (Selected != LastSelected && Selected >= 0)
            ActivatorSound("menu/click", 127);
        
        LastSelected = Selected;
        
        // Draw Wheel
        SetHudSize(640, 480, false);
        for (int i = 0; i < MAX_SKILLKEYS; i++)
        {
            fixed Angle = -0.25 + ((1.0 / MAX_SKILLKEYS) * i);
            fixed X = 320.0 + (CurrentRadius * Cos(Angle));
            fixed Y = 240.0 + (CurrentRadius * Sin(Angle));
            
            // Cursor
            if (i == Selected)
                PrintSprite("SelectBo", 0, (int)X, (int)Y, 0.05);
            
            // Slot Number
            SetFont("SMALLFONT");
            HudMessage("%d\n", i + 1, HUDMSG_FADEOUT, WHEEL_ID - MAX_SKILLKEYS + i, CR_GREEN, (int)(X + 16), (int)(Y - 16), 0.05, 1.0);
            
            // Icon
            if (Player.SkillCategory[i] != -1 && Player.SkillIndex[i] != -1)
                PrintSpriteFade(Skills[Player.SkillCategory[i]][Player.SkillIndex[i]].Icon, WHEEL_ID + i, (int)X, (int)Y, 0.05, 1.0);
            
            // Box
            PrintSpriteFade("ItemBox", WHEEL_ID + MAX_SKILLKEYS + i, (int)X, (int)Y, 0.05, 1.0);
        };
        
        // Animate Wheel
        if (CurrentRadius < Radius)
            CurrentRadius += GetCVar("drpg_skill_wheelspeed");
        
        // Skill Info
        if (CurrentSkill != nullptr)
        {
            int Cost = ScaleEPCost(CurrentSkill->Cost * CurrentSkill->CurrentLevel * Player.SkillCostMult);
            str CostColor = (Player.EP < Cost ? "\cg" : "\cv");
            str Info;
            
            // Build info string
            Info = StrParam("\cd%s\n\n\n", CurrentSkill->Name);
            Info = StrParam("%s\cjLevel: %d/%d\n\n", Info, CurrentSkill->CurrentLevel, CurrentSkill->Level);
            Info = StrParam("%s%s%d EP\n", Info, CostColor, Cost);
            
            // Display
            SetFont("SMALLFONT");
            SetHudClipRect(0, 0, 0, 0, 128);
            HudMessage("%s\n", Info, HUDMSG_FADEOUT, WHEEL_ID + (MAX_SKILLKEYS * 2), CR_WHITE, 320.4, 240.0, 0.05, 1.0);
            SetHudClipRect(0, 0, 0, 0, 0);
        };
        
        Delay(1);
    };
    
    Delay(1);
    goto Start;
};

acscript void UseSkill(int Key) net
{
    // Current Skill
    int Index = (Player.InMenu && Player.Menu == 3 ? -1 : Player.SkillSelected);
    Skill *CurrentSkill;
    
    // Quick Use handling
    if (Key > 0)
        CurrentSkill = &Skills[Player.SkillCategory[Key - 1]][Player.SkillIndex[Key - 1]]
    else
        CurrentSkill = &Skills[Player.SkillCategory[Index]][Player.SkillIndex[Index]];
    
    // If you're dead, terminate
    if (ClassifyActor(Player.TID) & ACTOR_DEAD) return;
    
    // If you have no current skill selected, terminate
    if (Player.SkillSelected == -1 && !Player.InMenu) return;
    
    // If the key is unassigned, terminate
    if (Index != -1)
        if (Player.SkillCategory[Index] == -1 || Player.SkillIndex[Index] == -1) return;
    
    // You can't use skills if you're Silenced
    if (Player.StatusType[SE_SILENCE]) return;
    
    // Quickuse
    if (Index == -1)
        CurrentSkill = &Skills[Player.SkillPage][Player.MenuIndex];
    
    int Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
    int OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
    int EPCost = ScaleEPCost(CurrentSkill->Cost * CurrentSkill->CurrentLevel * Player.SkillCostMult);
    bool Success;
    
    // Overdrive?
    Overdrive = false;
    if (Buttons & BT_SPEED && (!Player.InMenu && !Player.InShop))
        Overdrive = true;
    
    // Overdriving an unlearnt skill will learn it
    if (Overdrive && CheckInventory("DRPGSkillToken") > 0 && CurrentSkill->Level == 0)
    {
        CurrentSkill->Level++;
        CurrentSkill->CurrentLevel++;
        TakeInventory("DRPGSkillToken", 1);
        FadeRange(0, 255, 255, 0.5, 0, 255, 255, 0.0, 0.5);
        return;
    };
    
    // Check if the Skill has been learned yet
    if (CurrentSkill->Level == 0)
    {
        SetFont("BIGFONT");
        HudMessage("You don't know this skill yet\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("skills/fail", 127);
        return;
    };

    // Can't use skills while burned out
    if (Player.EP < 0)
    {
        SetFont("BIGFONT");
        HudMessage("You can't use skills while burned out\n", HUDMSG_FADEOUT, 0, CR_BLUE, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("skills/fail", 127);
        return;
    };
    
    // Use the Skill
    if (Player.EP >= EPCost || Overdrive)
    {
        // Data to pass to the script pointer
        void *Data = nullptr;
        auto int DataCategory = (Index == -1 ? Player.SkillPage : Player.SkillCategory[Player.SkillSelected]);
        auto int DataIndex = (Index == -1 ? Player.MenuIndex : Player.SkillIndex[Player.SkillSelected]);
        
        if (Key > 0)
        {
            DataCategory = Player.SkillCategory[Key - 1];
            DataIndex = Player.SkillIndex[Key - 1];
        };
        
        // Powerups, Auras and Summons need their index passed
        if (DataCategory == 1 || DataCategory == 2 || DataCategory == 4)
            Data = &DataIndex;
        
        // Debugging
        if (GetCVar("drpg_debug"))
        {
            Log("\cdDEBUG: \c-EP Cost for %s (\cdLevel %d\c-): \cn%d\n", CurrentSkill->Name, CurrentSkill->CurrentLevel, EPCost);
            Log("\cdDEBUG: \c-Data Category/Index: \cd%d\c-, \cd%d\n", DataCategory, DataIndex);
            Log("\cdDEBUG: \c-Skill Data passed: \cd%d\n", *(int *)Data);
        };
        
        // PWAA-9001 Accessory Handling - Increase skill level intermittently
        if (Player.Shield.Accessory == SHIELD_ACC_PWAA9001 && Player.Shield.Active && CurrentSkill->CurrentLevel < CurrentSkill->MaxLevel)
                CurrentSkill->CurrentLevel++;
        
        // Use Skill
        Success = CurrentSkill->Use(CurrentSkill, Data);
        
        // PWAA-9001 Accessory Handling - Change back to previous level
        if (Player.Shield.Accessory == SHIELD_ACC_PWAA9001 && Player.Shield.Active && CurrentSkill->CurrentLevel < CurrentSkill->MaxLevel)
            CurrentSkill->CurrentLevel--;
        
        // Check if the skill use was successful
        if (Success)
            Player.EP -= EPCost;
    }
    else // Not enough EP
    {
        SetFont("BIGFONT");
        HudMessage("Not enough EP to use this skill!\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("skills/fail", 127);
    };
};

acscript bool Heal(Skill *Self, void *Data)
{
    int HealAmount;
    
    // Calculate healing amount based on level
    HealAmount = 25 * Self->CurrentLevel;
    
    // Refund - If your health is max or above
    if (Player.ActualHealth >= Player.HealthMax && !HaveStatusEffect())
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    FadeRange(255, 0, 255, 0.5, 255, 0, 255, 0, 1.0);
    
    AddHealth(HealAmount, 100);
    ActivatorSound("skills/heal", 127);
    
    // Level 3+ - Remove Status Effects
    if (Self->Level > 2)
        ClearStatusEffects();
    
    return true;
};

acscript bool HealSummons(Skill *Self, void *Data)
{
    // Refund - If you have no summoned monsters
    if (Player.Summons == 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    FadeRange(255, 0, 255, 0.5, 255, 0, 255, 0, 1.0);
    
    for (int i = 0; i < MAX_SUMMONS; i++)
        if (Player.SummonTID[i] > 0)
        {
            MonsterStatsPtr Stats = &Monsters[GetMonsterID(Player.SummonTID[i])];
            SetActorProperty(Player.SummonTID[i], APROP_Health, Stats->HealthMax);
        };
    
    ActivatorSound("skills/heal2", 127);
    
    return true;
};

acscript bool HealTeam(Skill *Self, void *Data)
{
    int PlayerTID = Player.TID;
    int HealAmount;
    
    HealAmount = 25 * Self->CurrentLevel;
    
    for (int i = 0; i < MAX_PLAYERS; i++)
        if (PlayerInGame(i))
        {
            SetActivator(Players(i).TID);
            AddHealth(HealAmount, 100);
            
            // Level 3+ - Remove Status Effects
            if (Self->Level > 2)
                ClearStatusEffects();
            
            FadeRange(255, 0, 255, 0.25, 255, 0, 255, 0, 1.0);
            ActivatorSound("skills/heal", 127);
        };
     
    SetActivator(PlayerTID);
    
    return true;
};

acscript bool Decontaminate(Skill *Self, void *Data)
{
    if (Player.Toxicity <= 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    Player.Toxicity -= (25 * Self->CurrentLevel);
    Player.ToxicTimer = 0;
    Player.ToxicOffset = 0;
    Player.ToxicStage = 0;
    
    ActivatorSound("skills/decontaminate", 127);
    FadeRange(0, 255, 0, 0.5, 0, 255, 0, 0.0, 1.0 + (0.25 * Self->CurrentLevel));
    
    return true;
};

acscript bool Repair(Skill *Self, void *Data)
{
    int RepairAmount;
    
    // Calculate repair amount based on level
    switch (Self->CurrentLevel)
    {
    case 1: RepairAmount = Player.ArmorMax / 4;     break; // 25%
    case 2: RepairAmount = Player.ArmorMax / 2;     break; // 50%
    case 3: RepairAmount = Player.ArmorMax / 1.33;  break; // 75%
    case 4: RepairAmount = Player.ArmorMax;         break; // 100%
    };

    if (CheckInventory("Armor") > 0 && CheckInventory("Armor") < Player.ArmorMax)
    {
        FadeRange(0, 255, 0, 0.5, 0, 255, 0, 0, 1.0);
        GiveInventory("DRPGArmorBonus", RepairAmount);
        
        if (CheckInventory("Armor") > Player.ArmorMax)
        {
            int ArmorOverflow = CheckInventory("BasicArmor") - Player.ArmorMax;
            TakeInventory("BasicArmor", ArmorOverflow);
        };
        
        ActivatorSound("skills/repair", 127);
        return true;
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    return false;
};

acscript bool Powerup(Skill *Self, void *Data)
{
    int Index = *(int *)Data;
    
    switch (Index)
    {
    case 0: // Invulnerability
        if (CheckInventory("PowerInvulnerable"))
        {
            ActivatorSound("menu/error", 127);
            return false;
        };
        ActivatorSound("powerups/protect", 127);
        GiveInventory(StrParam("DRPGSkillInvulnerability%d\n", Self->CurrentLevel), 1);
        break;
    case 1: // Invisibility
        if (CheckInventory("PowerShadow"))
        {
            ActivatorSound("menu/error", 127);
            return false;
        };
        ActivatorSound("powerups/invis", 127);
        GiveInventory(StrParam("DRPGSkillInvisibility%d\n", Self->CurrentLevel), 1);
        break;
    case 3: // Iron Feet
        if (CheckInventory("PowerIronFeet"))
        {
            ActivatorSound("menu/error", 127);
            return false;
        };
        ActivatorSound("powerups/suit", 127);
        GiveInventory("PowerIronFeet", 1);
        break;
    case 4: // Night Vision
        if (CheckInventory("PowerLightAmp"))
        {
            ActivatorSound("menu/error", 127);
            return false;
        };
        ActivatorSound("powerups/light", 127);
        GiveInventory("PowerLightAmp", 1);
        break;
    case 5: // Berserk
        ActivatorSound("powerups/berserk", 127);
        GiveInventory("PowerStrength", 1);
        break;
    case 6: // Mental Mapping
        ActivatorSound("powerups/map", 127);
        GiveInventory("DRPGAllMapRevealer", 1);
        GiveInventory("DRPGAllMapScanner", 1);
        break;
    };
    
    return true;
};

acscript bool BulletTime(Skill *Self, void *Data)
{
    if (Self->CurrentLevel == 1) // Stutter Time
    {
        BulletTimeTimer = 350;
        SpawnForced("DRPGTimeFreezerQuickSound", GetActorX(0), GetActorY(0), GetActorZ(0), 0, 0);
        TakeInventory("PowerTimeFreezer", 1);
        GiveInventory("DRPGTimeFreezerQuick", 1);
    };
    if (Self->CurrentLevel == 2) // Freeze Time
    {
        SpawnForced("DRPGTimeFreezerSound", GetActorX(0), GetActorY(0), GetActorZ(0), 0, 0);
        GiveInventory("DRPGTimeFreezer", 1);
    };
    
    return true;
};

acscript bool DropWeapon(Skill *Self, void *Data)
{
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0) + Cos(Angle) * 96.0;
    fixed Y = GetActorY(0) + Sin(Angle) * 96.0;
    fixed Z = GetActorZ(0) + 48.0;
    str Weapon;
    
    switch (Self->CurrentLevel)
    {
    case 1: Weapon = "Pistol";          break;
    case 2: Weapon = "Shotgun";         break;
    case 3: Weapon = "SuperShotgun";    break;
    case 4: Weapon = "Chaingun";        break;
    case 5: Weapon = "RocketLauncher";  break;
    case 6: Weapon = "PlasmaRifle";     break;
    case 7: Weapon = "BFG9000";         break;
    };
    
    if (Spawn(Weapon, X, Y, Z, 0, Angle))
    {
        ActivatorSound("skills/drop", 127);
        Spawn("TeleportFog", X, Y, Z, 0, Angle);
        return true;
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    return false;
};

acscript bool DropAmmo(Skill *Self, void *Data)
{
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0) + Cos(Angle) * 96.0;
    fixed Y = GetActorY(0) + Sin(Angle) * 96.0;
    fixed Z = GetActorZ(0) + 48.0;
    str Ammo;
    
    switch (Self->CurrentLevel)
    {
    case 1:         Ammo = "DRPGSmallBackpack"; break;
    case 2:         Ammo = "DRPGBackpack";      break;
    case 3: case 4: Ammo = "DRPGBigBackpack";   break;
    };
    
    if (Spawn(Ammo, X, Y, Z, 0, Angle))
    {
        if (Self->CurrentLevel == 4 && GetCVar("drpg_ext_doomrl"))
            Spawn("RLSupplyCrate", X, Y, Z, 0, Angle);
        
        ActivatorSound("skills/drop", 127);
        Spawn("TeleportFog", X, Y, Z, 0, Angle);
        return true;
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };

    return false;
};

acscript bool UseAura(Skill *Self, void *Data)
{
    int Index = *(int *)Data;
    
    ActivatorSound("skills/buff", 127);
    
    if (Player.Perks[STAT_ENERGY])
        Player.AuraTimer += (1050 + Player.Energy * 5.25) * (Player.AuraBonus ? 2 : 1)
    else
    {
        bool Stack = false;
        
        // Is the Aura you used the same as the one you already have active?
        if (Player.Aura[Index])
            Stack = true;
        
        // Remove all other Auras first
        for (int i = 0; i < AURA_MAX; i++)
            Player.Aura[i] = false;
        
        // Should the timer be stacked because you used the same Aura?
        if (Stack)
            Player.AuraTimer += (1050 + Player.Energy * 5.25) * (Player.AuraBonus ? 2 : 1)
        else
            Player.AuraTimer = (1050 + Player.Energy * 5.25) * (Player.AuraBonus ? 2 : 1);
    };
    
    // Apply Aura
    Player.Aura[Index] = true;
    
    // Aura Cost Multiplier
    Player.AuraCostMult += 0.1;
    
    return true;
};

acscript bool Weaken(Skill *Self, void *Data)
{
    int PlayerNum = PlayerNumber();
    
    SetActivatorToTarget(Players(PlayerNum).TID);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    // Refund - If the Player has no target
    if (ActivatorTID() == Players(PlayerNum).TID)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Refund - If the target isn't actually a valid monster
    if (!Stats->Init || !(ClassifyActor(0) & ACTOR_MONSTER))
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    // Halve the monster's level and stats
    Stats->Level /= 2;
    Stats->Strength /= 2;
    Stats->Defense /= 2;
    Stats->Vitality /= 2;
    Stats->Energy /= 2;
    Stats->Regeneration /= 2;
    Stats->Agility /= 2;
    Stats->Capacity /= 2;
    Stats->Luck /= 2;
    
    // Destroy Aura
    if (Self->CurrentLevel == 2) 
        Stats->Aura = 0;
    
    // Cap Level
    if (Stats->Level < 1)
        Stats->Level = 1;
    
    // Re-calculate the monster's threat level
    Stats->Threat = CalculateMonsterThreatLevel(0);
    
    // Reset Activator
    SetActivator(Players(PlayerNum).TID);
    
    FadeRange(0, 0, 0, 0.25, 0, 0, 0, 0.0, 1.0);
    ActivatorSound("skills/weaken", 127);
    return true;
};

acscript bool Translocate(Skill *Self, void *Data)
{
    FireProjectile("DRPGTranslocateBall");
    return true;
};

acscript bool Repulse(Skill *Self, void *Data)
{
    SetInventory(StrParam("DRPGSkillBlast%d\n", Self->CurrentLevel), 1);
    UseInventory(StrParam("DRPGSkillBlast%d\n", Self->CurrentLevel));
    
    FadeRange(255, 255, 0, 0.1, 255, 255, 0, 0.0, 0.5 + (0.25 * Self->CurrentLevel));
    
    return true;
};

acscript bool AuraSteal(Skill *Self, void *Data)
{
    int PlayerNum = PlayerNumber();
    int AuraType;
    int AuraTime;
    
    SetActivatorToTarget(Players(PlayerNum).TID);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    // Refund - If the Player has no target
    if (ActivatorTID() == Players(PlayerNum).TID)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Refund - If the target isn't actually a valid monster
    if (!Stats->Init || !(ClassifyActor(0) & ACTOR_MONSTER))
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    // Refund - If the target doesn't have an Aura or has a Shadow Aura
    if (Stats->Aura == 0 || Stats->Aura == 10)
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    // Get Aura info
    AuraType = Stats->Aura - 1;
    AuraTime = (Stats->Level < 30 ? 30 : Stats->Level) * 35;
    
    // Remove Aura from monster
    Stats->Aura = 0;
    
    SetActivator(Players(PlayerNum).TID);
    
    // Apply Aura to player
    Player.Aura[AuraType] = true;
    Player.AuraTimer += AuraTime;
    
    ActivatorSound("skills/aurasteal", 127);
    return true;
};

acscript bool SoulSteal(Skill *Self, void *Data)
{
    str[] SoulTypes =
    {
        "DRPGSoulRed";
        "DRPGSoulGreen";
        "DRPGSoulWhite";
        "DRPGSoulPink";
        "DRPGSoulBlue";
        "DRPGSoulPurple";
        "DRPGSoulOrange";
        "DRPGSoulDarkBlue";
        "DRPGSoulYellow";
        "DRPGSoulBlack";
    };
    
    int PlayerNum = PlayerNumber();
    int SoulTID;
    int UniqueMonsterTID = UniqueTID();
    int RealMonsterTID;
    int BeforeHealthAmount;
    int AfterHealthAmount;
    bool AllowsXP;
    
    // Move activation to the user's target
    SetActivatorToTarget(Players(PlayerNum).TID);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    // Refund - If the Player has no target
    if (ActivatorTID() == Players(PlayerNum).TID)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Refund - If the target isn't actually a valid monster
    if (!Stats->Init || !(ClassifyActor(0) & ACTOR_MONSTER))
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    // Refund - If the target has a Shadow Aura, is a boss or can never have an aura to begin with
    if (Stats->Aura == 10 || Stats->Flags & MF_BOSS || Stats->Flags & MF_NOAURA || CheckFlag(0, "BOSS"))
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    // Leech Amount
    int LeechAmount = (int)((fixed)Stats->HealthMax * ((fixed)Self->CurrentLevel / 10.0));
    if (LeechAmount < 1)
        LeechAmount = 1;
    
    AllowsXP = !(Stats->Flags & MF_NOXP);
    
    // Don't gain XP from this
    if (AllowsXP)
        Stats->Flags |= MF_NOXP;
    
    // Temporary changing of TID to handle giving XP properly
    RealMonsterTID = ActivatorTID();
    Thing_ChangeTID(0, UniqueMonsterTID);
    
    BeforeHealthAmount = GetActorProperty(0, APROP_Health);
    
    /* Damage Enemy (old method)
    SetActivator(Players(PlayerNum).TID);
    Thing_Damage2(UniqueMonsterTID, LeechAmount, "LifeSteal");
    SetActivator(UniqueMonsterTID);
    */
    
    // Damage Enemy (current method)
    SetActivator(Players(PlayerNum).TID);
    SetActorProperty(UniqueMonsterTID, APROP_Health, GetActorProperty(UniqueMonsterTID, APROP_Health) - LeechAmount);
    SetActivator(UniqueMonsterTID);
    
    AfterHealthAmount = GetActorProperty(0, APROP_Health);
    if (AfterHealthAmount < 0)
        AfterHealthAmount = 0;
    
    LeechAmount = BeforeHealthAmount - AfterHealthAmount; // Only heal based on how much we *actually* took
    
    // Drop the Soul and apply the stat to the uservar
    if (GetActorProperty(0, APROP_Health) <= 0)
        SoulTID = DropMonsterItem(PlayerNum, 0, SoulTypes[(Stats->Aura > 0 ? Stats->Aura - 1 : Random(0, SOUL_MAX - 1))], 256)
    else if (AllowsXP) // Stats->Flags &= ~MF_NOXP; // TODO: Notify DavidPH that this doesn't work
        Stats->Flags &= ~0x02;
    
    // Move activation back to the user
    SetActivator(Players(PlayerNum).TID);
    
    // Reset the temporary TID
    Thing_ChangeTID(UniqueMonsterTID, RealMonsterTID);
    
    // Late Refund - If we did no damage to the target at all
    if (!LeechAmount)
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    // Heal the user
    AddHealthDirect(LeechAmount, 100);
    
    FadeRange(0, 0, 0, 0.5, 0, 0, 0, 0.0, 0.25);
    ActivatorSound("skills/soulsteal", 127);
    return true;
};

acscript bool Summon(Skill *Self, void *Data)
{
    int Index = *(int *)Data;
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0);
    int NewID = UniqueTID();
    bool Success;
    fixed Radius;
    str Name;
    
    str[] Summons =
    {
        "ZombieMan";
        "ShotgunGuy";
        "ChaingunGuy";
        "DoomImp";
        "Demon";
        "Cacodemon";
        "HellKnight";
        "BaronOfHell";
        "LostSoul";
        "PainElemental";
        "Revenant";
        "Fatso";
        "Arachnotron";
        "Archvile";
        "Cyberdemon";
        "SpiderMastermind";
    };
    
    str[][] DRLASummons =
    {
        // Former Human
        {
            "RLDRPGSummonedFormerHuman";
            "RLDRPGSummonedEliteHuman";
            "RLDRPGSummonedFormerCaptain";
        };
        
        // Former Sergeant
        {
            "RLDRPGSummonedFormerSergeant";
            "RLDRPGSummonedEliteSergeant";
        };
        
        // Former Commando
        {
            "RLDRPGSummonedFormerCommando";
            "RLDRPGSummonedEliteCommando";
            "RLDRPGSummonedEliteCaptain2";
        };
        
        // Imp
        {
            "RLDRPGSummonedImp";
            "RLDRPGSummonedNightmareImp";
            "RLDRPGSummonedCyberneticImp";
        };
        
        // Demon
        {
            "RLDRPGSummonedDemon";
            "RLDRPGSummonedSpectre";
            "RLDRPGSummonedNightmareDemon";
            "RLDRPGSummonedNightmareSpectre";
            "RLDRPGSummonedCyberneticDemon";
            "RLDRPGSummonedCyberneticSpectre";
        };
        
        // Cacodemon
        {
            "RLDRPGSummonedCacodemon";
            "RLDRPGSummonedNightmareCacodemon";
        };
        
        // Hell Knight
        {
            "RLDRPGSummonedHellKnight";
            "RLDRPGSummonedNightmareHellKnight";
            "RLDRPGSummonedCyberneticHellKnight";
        };
        
        // Baron of Hell
        {
            "RLDRPGSummonedBaronOfHell";
            "RLDRPGSummonedNightmareBaronOfHell";
            "RLDRPGSummonedCyberneticBaronOfHell";
        };
        
        // Lost Soul
        {
            "RLDRPGSummonedLostSoul";
            "RLDRPGSummonedNightmareLostSoul";
            "RLDRPGSummonedCyberneticLostSoul";
        };
        
        // Pain Elemental
        {
            "RLDRPGSummonedPainElemental";
            "RLDRPGSummonedNightmarePainElemental";
        };
        
        // Revenant
        {
            "RLDRPGSummonedRevenant";
            "RLDRPGSummonedNightmareRevenant";
            "RLDRPGSummonedCyberneticRevenant";
        };
        
        // Mancubus
        {
            "RLDRPGSummonedMancubus";
            "RLDRPGSummonedNightmareMancubus";
            "RLDRPGSummonedCyberneticMancubus";
        };
        
        // Arachnotron
        {
            "RLDRPGSummonedArachnotron";
            "RLDRPGSummonedNightmareArachnotron";
            "RLDRPGSummonedCyberneticArachnotron";
        };
        
        // Arch-Vile
        {
            "RLDRPGSummonedArchVile";
            "RLDRPGSummonedNightmareArchVile";
        };
        
        // Cyberdemon
        {
            "RLDRPGSummonedCyberdemon";
            "RLDRPGSummonedNightmareCyberdemon";
        };
        
        // Spider Mastermind
        {
            "RLDRPGSummonedSpiderMastermind";
            "RLDRPGSummonedCyberneticSpiderMastermind";
        };
    };
    
    // Stop if you're in the Outpost
    if (InBase)
    {
        SetFont("BIGFONT");
        HudMessage("You cannot summon friendlies here\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Stop if you already have the maximum amount of summons
    if (Player.Summons >= MAX_SUMMONS)
    {
        SetFont("BIGFONT");
        HudMessage("You cannot summon any more friendlies\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    if (Index == 0) // Marines
    {
        switch (Self->CurrentLevel)
        {
        case 1: Name = "DRPGMarineGuardPistolSummoned";    break;
        case 2: Name = "DRPGMarineShotgunSummoned";        break;
        case 3: Name = "DRPGMarineDoubleShotgunSummoned";  break;
        case 4: Name = "DRPGMarineChaingunSummoned";;      break;
        case 5: Name = "DRPGMarineRocketLauncherSummoned"; break;
        case 6: Name = "DRPGMarinePlasmaRifleSummoned";    break;
        case 7: Name = "DRPGMarineBFG9000Summoned";        break;
        };
    }
    else // Monsters
    {
        if (GetCVar("drpg_ext_doomrl"))
            Name = DRLASummons[Index - 1][Self->CurrentLevel - 1]
        else if (GetCVar("drpg_ext_extras"))
            Name = StrParam("DRPG%sExtras\n", Summons[Index - 1])
        else
            Name = StrParam("DRPG%s\n", Summons[Index - 1]);
    };
    
    // Perform a dummy summon to get the Radius and add it to X and Y
    SpawnForced(Name, 0, 0, 0, NewID, 0);
    Radius = GetActorPropertyFixed(NewID, APROP_Radius);
    X += Cos(Angle) * (Radius * 1.5 + 16.0);
    Y += Sin(Angle) * (Radius * 1.5 + 16.0);
    Thing_Remove(NewID);
    
    // With the new radius, try and summon the actual monster
    Success = Spawn(Name, X, Y, Z, NewID, Angle);
    
    if (Success)
    {
        SpawnForced("TeleportFog", X, Y, Z, 0, Angle);
        SetActorAngle(NewID, Angle);
        SetActorProperty(NewID, APROP_Friendly, 1);
        SetActorProperty(NewID, APROP_MasterTID, Player.TID);
        GiveActorInventory(NewID, "DRPGFriendlyBooster", 1);
        
        // Setup Stats
        Delay(4); // We need this initial delay to make sure the ID is valid
        MonsterStatsPtr Stats = &Monsters[GetMonsterID(NewID)];
        fixed Modifier = 1.0 + (fixed)Player.Level * ((fixed)Player.Energy / 20.0);
        Stats->Level = Modifier;
        Stats->Strength = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Defense = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Vitality = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Energy = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Regeneration = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Agility = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Capacity = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Luck = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Threat = CalculateMonsterThreatLevel(&Monsters[GetMonsterID(NewID)]);
        Stats->Flags |= MF_NODROPS;
        Stats->NeedReinit = true;
        
        // Add summon to your summon array
        for (int i = 0; i < MAX_SUMMONS; i++)
            if (Player.SummonTID[i] == 0)
            {
                Player.SummonTID[i] = NewID;
                Player.Summons++;
                return true;
            };
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
};

acscript bool BreakdownArmor(Skill *Self, void *Data)
{
    int Armor = CheckInventory("BasicArmor");
    
    // Kind of hackish to prevent breaking down Armors that use high values for indestructibleness
    if (Armor > 1000)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    if (Armor > 0)
    {
        TakeInventory("BasicArmor", Armor);
        GiveInventory("DRPGCredits", Armor);
        
        // DoomRL Compatibility
        if (GetCVar("drpg_ext_doomrl"))
        {
            TakeInventory("RL100ArmorWorn", 1);
            TakeInventory("RL150ArmorWorn", 1);
            TakeInventory("RL200ArmorWorn", 1);
            TakeInventory("RL100RegenArmorWorn", 1);
            TakeInventory("RLIndestructibleArmorWorn", 1);
        };
        
        ActivatorSound("skills/breakdown", 127);
        return true;
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    return false;
};

acscript bool ForceWall(Skill *Self, void *Data)
{
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0) + Cos(Angle) * 96.0;
    fixed Y = GetActorY(0) + Sin(Angle) * 96.0;
    fixed Z = GetActorZ(0);
    
    Thing_Remove(ForceFieldTID + PlayerNumber());
    
    switch (Self->CurrentLevel)
    {
    case 1:
        if (!Spawn("DRPGForceField", X, Y, Z, ForceFieldTID + PlayerNumber(), Angle) == 0) {return true;}
        else
        {
            ActivatorSound("menu/error", 127);
            return false;
        };
        break;
    case 2:
        if (!Spawn("DRPGForceField2", X, Y, Z, ForceFieldTID + PlayerNumber(), Angle) == 0) {return true;}
        else
        {
            ActivatorSound("menu/error", 127);
            return false;
        };
        break;
    };

    return false;
};

acscript bool Rally(Skill *Self, void *Data)
{
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0);
    fixed Angle = GetActorAngle(0);
    
    // Fail if you have no summons active
    if (Player.Summons == 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    SpawnForced("TeleportFog", X, Y, Z, 0, Angle);
    
    for (int i = 0; i < MAX_SUMMONS; i++)
        if (Player.SummonTID[i] > 0)
            SetActorPosition(Player.SummonTID[i], X, Y, Z, 0);
    
    ActivatorSound("skills/rally", 127);
    return true;
};

acscript bool Unsummon(Skill *Self, void *Data)
{
    int EPAdd;
    
    // Fail if you have no summons active
    if (Player.Summons == 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    for (int i = 0; i < MAX_SUMMONS; i++)
    {
        // Continue if there's no summon in this slot
        if (Player.SummonTID[i] == 0) continue;
        
        if (Self->CurrentLevel == 2 && GetActorProperty(i, APROP_Health) > 0)
            EPAdd += 25;
        
        // Overdrive - Remove summons (teleport out) instead of killing them
        if (GetActorProperty(Player.SummonTID[i], APROP_Health) > 0)
        {
            SpawnForced("TeleportFog", GetActorX(Player.SummonTID[i]), GetActorY(Player.SummonTID[i]), GetActorZ(Player.SummonTID[i]), 0, 0);
            Thing_Remove(Player.SummonTID[i]);
        };
        
        // Remove the summon from the array
        Player.SummonTID[i] = 0;
    };
    
    
    if (Self->CurrentLevel == 2)
        Player.EP += EPAdd;

    Player.Summons = 0;
    
    FadeRange(192, 0, 0, 0.5, 192, 0, 0, 0.0, 1.0);
    ActivatorSound("skills/unsummon", 127);
    return true;
};

acscript bool Recall(Skill *Self, void *Data)
{
    // Fail if you're in the Arena or Marines are hostile
    if (ArenaActive || MarinesHostile)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
        
    SetInventory("ArtiTeleport", 1);
    UseInventory("ArtiTeleport");
    return true;
};

acscript bool Magnetize(Skill *Self, void *Data)
{
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0) + (GetActorProperty(0, APROP_Height) / 2);
    fixed AngleAdd;
    int ItemCount;
    auto int[MAX_DROPS] ItemTIDs;
    
    CleanDropTIDArray();
    
    // Count all the items in the DropTID array
    for (int i = 0; i < MAX_DROPS; i++)
    {
        if (Player.DropTID[i] != -1)
        {
            ItemTIDs[ItemCount] = Player.DropTID[i];
            ItemCount++;
        };
    };
    
    // Refund - If there are no items in the array
    if (ItemCount == 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Overdrive - Pull the items on top of you and pick them all up
    if (Overdrive)
    {
        for (int i = 0; i < ItemCount; i++)
            SetActorPosition(ItemTIDs[i], X, Y, Z, 0);
        
        SetActorVelocity(0, 0.01, 0.01, 0, true, false);
        
        FadeRange(0, 0, 0, 0.5, 0, 0, 0, 0.0, 1.0);
        ActivatorSound("skills/magnet", 127);
        return true;
    };
    
    AngleAdd = 1.0 / ItemCount;
    
    for (int i = 0; i < ItemCount; i++)
    {
        X = GetActorX(0) + Cos(Angle) * 64.0;
        Y = GetActorY(0) + Sin(Angle) * 64.0;
        SetActorPosition(ItemTIDs[i], X, Y, Z, 0);
        Angle += AngleAdd;
    };
    
    FadeRange(0, 0, 0, 0.5, 0, 0, 0, 0.0, 1.0);
    ActivatorSound("skills/magnet", 127);
    return true;
};

acscript bool WirelessLocker(Skill *Self, void *Data)
{
    Locker(true, Self->CurrentLevel);
    return true;
};

acscript bool Transport(Skill *Self, void *Data)
{
    // If you're dead, terminate
    if (ClassifyActor(Player.TID) & ACTOR_DEAD) return false;
    
    // Don't allow Transport while the arena is active, if the Marines are hostile, or you're in an Outpost-related menu
    if (ArenaActive || MarinesHostile || Player.OutpostMenu > 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Multiplayer
    if (InMultiplayer && PlayerCount() > 1)
    {
        int Players = PlayerCount();
        bool Ready;
        bool[MAX_PLAYERS] Voted;
        int PlayersApprove;
        int PlayersDeny;
        
        for (int i = 0; i < MAX_PLAYERS; i++)
            Voted[i] = false;
        
        while (!Ready)
        {
            // Freeze all players
            SetPlayerProperty(true, 1, PROP_TOTALLYFROZEN);
            
            // Input
            for (int i = 0; i < Players; i++)
            {
                // Skip input checks if you've already voted
                if (Voted[i]) continue;
                
                int Buttons = GetPlayerInput(i, INPUT_BUTTONS);
                int OldButtons = GetPlayerInput(i, INPUT_OLDBUTTONS);
                
                if (Buttons == BT_USE && OldButtons != BT_USE)
                {
                    ActivatorSound("menu/move", 127);
                    PlayersApprove++;
                    Voted[i] = true;
                };
                if (Buttons == BT_SPEED && OldButtons != BT_SPEED)
                {
                    ActivatorSound("menu/move", 127);
                    PlayersDeny++;
                    Voted[i] = true;
                };
            };
            
            // Check that everyone has voted
            Ready = true;
            for (int i = 0; i < Players; i++)
                if (!Voted[i]) Ready = false;
            
            // Drawing
            SetFont("BIGFONT");
            HudMessageBold("\cd%N\c- has requested Transport\n\c-Players: %d (\cd%d\c-/\cg%d\c-)\n\n\cd%K\c- to Approve\n\cd%K\c- to Deny\n",
                           PlayerNumber() + 1, Players, PlayersApprove, PlayersDeny, "+use", "+speed",
                           HUDMSG_FADEOUT, MENU_ID, CR_WHITE, 0.5, 0.75, 1.0, 4.0);
            
            Delay(1);
        };
        
        // Ready - tally votes and confirm/deny Transport
        if (Ready)
        {
            SetPlayerProperty(true, 0, PROP_TOTALLYFROZEN);
            
            // Approved
            if (PlayersApprove > PlayersDeny)
            {
                for (int i = 0; i < MAX_PLAYERS; i++)
                    SetActorProperty(Players(i).TID, APROP_Invulnerable, true);
                HudMessageBold("\cdTransport Approved!\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.5, 1.0, 4.0);
                Delay(35 * 2);
                FadeRange(255, 255, 255, 0.0, 255, 255, 255, 1.0, 3.0);
                Delay(35 * 3);
            };
            
            // Denied
            if (PlayersDeny > PlayersApprove)
            {
                HudMessageBold("\cgTransport Denied!\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.5, 1.0, 2.0);
                return false;
            };
            
            // Draw
            if (PlayersApprove == PlayersDeny)
            {
                HudMessageBold("\cjDraw!\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.5, 1.0, 2.0);
                return false;
            };
        };
    }
    else // Single Player
    {
        // Fade Screen
        FadeRange(255, 255, 255, 0.0, 255, 255, 255, 1.0, 1.0);
        
        // Freeze Player
        SetActorProperty(0, APROP_Invulnerable, true);
        SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
        
        // Delay and unfreeze Player
        Delay(35);
        SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
        SetActorProperty(0, APROP_Invulnerable, false);
    };
    
    // Transport
    if (!InBase)
    {
        LastVisitedLevel = FindLevelInfoIndex();
        
        // Just in case we warp to Outpost from a map with no index, default to MAP01
        if (LastVisitedLevel < 0) LastVisitedLevel = 0;
        
        ChangeLevel("OUTPOST", 0, CHANGELEVEL_NOINTERMISSION, -1);
        InBase = true;
        Transported = true;
        return true;
    }
    else
    {
        ChangeLevel(KnownLevels[LastVisitedLevel].LumpName, 0, CHANGELEVEL_NOINTERMISSION, -1);
        InBase = false;
        Transported = true;
        return true;
    };
};

acscript void RemoveAura()
{
    for (int i = 0; i < AURA_MAX; i++)
        Player.Aura[i] = false;
    
    Player.AuraTimer = 0;
};

acscript void ClearStatusEffects()
{
    for (int i = 0; i < SE_MAX; i++)
    {
        if (i == SE_RADIATION && Player.StatusType[i])
            StopSound(Player.TID, 7);
        
        Player.StatusType[i] = false;
        Player.StatusTypeHUD = 0;
        Player.StatusIntensity[i] = 0;
        Player.StatusTimer[i] = 0;
        Player.StatusTimerMax[i] = 0;
    };
};

script void CleanDropTIDArray()
{
    // [KS] !!WARNING!! THIS CANNOT BE A FUNCTION.
    for (int i = 0; i < MAX_DROPS; i++)
        if (Player.DropTID[i] != -1 && ClassifyActor(Player.DropTID[i]) == ACTOR_NONE)
            Player.DropTID[i] = -1;
};

function int ScaleEPCost(int Cost)
{
    fixed ScaleCost;
    
    // Multiplier CVAR
    ScaleCost = (fixed)Cost * GetCVarFixed("drpg_skill_costscale");
    
    // Aura Multiplier
    ScaleCost *= 1.0 + Player.AuraCostMult;
    
    return ScaleCost;
};

function void CheckSkills()
{
    // Aura-related vars to save typing :P
    int RedAuraLevel = Skills[2][0].CurrentLevel;
    int GreenAuraLevel = Skills[2][1].CurrentLevel;
    int WhiteAuraLevel = Skills[2][2].CurrentLevel;
    int PinkAuraLevel = Skills[2][3].CurrentLevel;
    int BlueAuraLevel = Skills[2][4].CurrentLevel;
    int PurpleAuraLevel = Skills[2][5].CurrentLevel;
    int OrangeAuraLevel = Skills[2][6].CurrentLevel;
    int DarkBlueAuraLevel = Skills[2][7].CurrentLevel;
    int YellowAuraLevel = Skills[2][8].CurrentLevel;
    fixed LuckMult = 1;
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0);
    int Angle = GetActorAngle(0) * 256;
    int AmmoRegenMult = 1;
    bool Shadow = (Player.Aura[AURA_RED] && Player.Aura[AURA_GREEN] && Player.Aura[AURA_WHITE] &&
                   Player.Aura[AURA_PINK] && Player.Aura[AURA_BLUE] && Player.Aura[AURA_PURPLE] &&
                   Player.Aura[AURA_ORANGE] && Player.Aura[AURA_DARKBLUE] && Player.Aura[AURA_YELLOW]);
    
    // Reset the Skill multiplier from the Blue Aura and Energy Augmentation
    Player.SkillCostMult = 1.0;
    
    // Level 4 and 5 of the Energy Augmentation reduce skill costs by 25% and 50%
    if (Player.Augs.Active[AUG_ENERGY])
        if (Player.Augs.Level[AUG_ENERGY] == 4)
            Player.SkillCostMult = 0.75
        else if (Player.Augs.Level[AUG_ENERGY] >= 5)
            Player.SkillCostMult = 0.5;
            
    // Give the player the Aura item while an Aura is active (for SBARINFO hax)
    if (Player.AuraTimer > 0)
        GiveInventory("DRPGAura", 1)
    else
        TakeInventory("DRPGAura", 1);
    
    // Aura handling
    if (Player.AuraTimer > 0)
    {
        // Red Aura
        if (Player.Aura[AURA_RED])
            if (Player.SoulActive[SOUL_RED])
                GiveInventory("DRPGRedAuraDamage6", 1)
            else if (RedAuraLevel >= 1)
                GiveInventory(StrParam("DRPGRedAuraDamage%d\n", RedAuraLevel), 1);
        
        // Green Aura
        if (Player.Aura[AURA_GREEN])
        {
            if (GreenAuraLevel == 1)
                Player.DamageFactor = Player.DamageFactor - Player.DamageFactor * 0.25;
            if (GreenAuraLevel == 2)
                Player.DamageFactor = Player.DamageFactor - Player.DamageFactor * 0.5;
            if (GreenAuraLevel == 3 || Player.SoulActive[SOUL_GREEN])
            {
                Player.DamageFactor = Player.DamageFactor - Player.DamageFactor * 0.75;
                GiveInventory("DRPGGreenAuraIronFeet", 1);
            };
        };
        
        // White Aura
        if (Player.Aura[AURA_WHITE])
        {
            if (WhiteAuraLevel >= 2 || Player.SoulActive[SOUL_WHITE])
            {
                if (Player.Combo == 0) Player.Combo++;
                Player.ComboTimer = COMBO_MAX - 1;
            };
            if (WhiteAuraLevel == 3)
                if ((Timer() % (35 * 4)) == 1)
                    Player.XPGained += XPTable[Player.Level] / 100 / (Player.Level + 1);
            if (WhiteAuraLevel >= 4 || Player.SoulActive[SOUL_WHITE])
                if ((Timer() % (35 * 2)) == 1)
                    Player.XPGained += XPTable[Player.Level] / 100 / (Player.Level + 1);
        };
        
        // Pink Aura
        if (Player.Aura[AURA_PINK])
            if (PinkAuraLevel >= 2 || Player.SoulActive[SOUL_PINK])
                GiveInventory("DRPGPinkAuraDrain", 1);
        
        // Blue Aura
        if (Player.Aura[AURA_BLUE])
        {
            if (BlueAuraLevel == 1)
                Player.SkillCostMult /= 1.33;
            if (BlueAuraLevel == 2)
                Player.SkillCostMult /= 2;
            if (BlueAuraLevel == 3 || Player.SoulActive[SOUL_BLUE])
                Player.SkillCostMult /= 4;
        };
        
        // Purple Aura
        if (Player.Aura[AURA_PURPLE])
        {
            if (PurpleAuraLevel == 1)
            {
                Player.HPAmount *= 2;
                Player.EPAmount *= 2;
            };
            if (PurpleAuraLevel == 2)
            {
                Player.HPAmount *= 3;
                Player.EPAmount *= 3;
            };
            if (PurpleAuraLevel == 3)
            {
                Player.HPAmount *= 4;
                Player.EPAmount *= 4;
            };
            if (PurpleAuraLevel == 4 || Player.SoulActive[SOUL_PURPLE])
            {
                Player.HPAmount *= 4;
                Player.EPAmount *= 4;
                Player.HPTime /= 2;
                Player.EPTime /= 2;
            };
        };
        
        // Orange Aura
        if (Player.Aura[AURA_ORANGE])
        {
            if (OrangeAuraLevel >= 1 || Player.SoulActive[SOUL_ORANGE])
                Player.Speed *= 2;
            if (OrangeAuraLevel >= 2 || Player.SoulActive[SOUL_ORANGE])
                Player.JumpHeight *= 2;
            if (OrangeAuraLevel >= 3 || Player.SoulActive[SOUL_ORANGE])
                Player.WeaponSpeed = 100;
        };

        // Dark Blue Aura
        if (Player.Aura[AURA_DARKBLUE])
        {
            if (DarkBlueAuraLevel == 5)
                AmmoRegenMult = 2;
            if (DarkBlueAuraLevel == 6 || Player.SoulActive[SOUL_DARKBLUE])
                AmmoRegenMult = 4;
            if (DarkBlueAuraLevel >= 1 || Player.SoulActive[SOUL_DARKBLUE])
                if ((Timer() % (35 / 2)) == 0)
                    GiveInventory("Clip", AmmoRegenMult);
            if (DarkBlueAuraLevel >= 2 || Player.SoulActive[SOUL_DARKBLUE])
                if ((Timer() % 35) == 1)
                    GiveInventory("Shell", AmmoRegenMult);
            if (DarkBlueAuraLevel >= 3 || Player.SoulActive[SOUL_DARKBLUE])
                if ((Timer() % (35 * 2)) == 0)
                    GiveInventory("RocketAmmo", AmmoRegenMult);
            if (DarkBlueAuraLevel >= 4 || Player.SoulActive[SOUL_DARKBLUE])
                if ((Timer() % (35 / 2)) == 0)
                    GiveInventory("Cell", AmmoRegenMult);
            if (DarkBlueAuraLevel >= 7 || Player.SoulActive[SOUL_DARKBLUE])
                GiveInventory("DRPGDarkBlueAuraInfiniteAmmo", 1);
        };
        
        // Yellow Aura
        if (Player.Aura[AURA_YELLOW])
        {
            if ((Timer() % (35 * (6 - YellowAuraLevel))) == 1)
                GiveInventory("DRPGCredits", (Player.RankLevel + 1));
            if (YellowAuraLevel == 1)
                LuckMult = 1.25;
            if (YellowAuraLevel == 2)
                LuckMult = 1.5;
            if (YellowAuraLevel == 3)
                LuckMult = 2;
            if (YellowAuraLevel == 4)
                LuckMult = 4;
            if (YellowAuraLevel == 5 || Player.SoulActive[SOUL_YELLOW])
                LuckMult = 8;
            
            Player.HealthChance *= LuckMult;
            Player.EPChance *= LuckMult;
            Player.ArmorChance *= LuckMult;
            Player.PowerupChance *= LuckMult;
            Player.WeaponChance *= LuckMult;
            Player.TokenChance *= LuckMult;
            Player.AugChance *= LuckMult;
            Player.ShieldChance *= LuckMult;
            Player.StimChance *= LuckMult;
        };
        
        // Spawn Aura FX
        if (Player.Aura[AURA_RED] && !(GetCVar("drpg_simple_auras") == 0 && Shadow))
            SpawnAura(Player.TID, AURA_RED + 1, false);
        if (Player.Aura[AURA_GREEN] && !(GetCVar("drpg_simple_auras") == 0 && Shadow))
            SpawnAura(Player.TID, AURA_GREEN + 1, false);
        if (Player.Aura[AURA_WHITE] && !(GetCVar("drpg_simple_auras") == 0 && Shadow))
            SpawnAura(Player.TID, AURA_WHITE + 1, false);
        if (Player.Aura[AURA_PINK] && !(GetCVar("drpg_simple_auras") == 0 && Shadow))
            SpawnAura(Player.TID, AURA_PINK + 1, false);
        if (Player.Aura[AURA_BLUE] && !(GetCVar("drpg_simple_auras") == 0 && Shadow))
            SpawnAura(Player.TID, AURA_BLUE + 1, false);
        if (Player.Aura[AURA_PURPLE] && !(GetCVar("drpg_simple_auras") == 0 && Shadow))
            SpawnAura(Player.TID, AURA_PURPLE + 1, false);
        if (Player.Aura[AURA_ORANGE] && !(GetCVar("drpg_simple_auras") == 0 && Shadow))
            SpawnAura(Player.TID, AURA_ORANGE + 1, false);
        if (Player.Aura[AURA_DARKBLUE] && !(GetCVar("drpg_simple_auras") == 0 && Shadow))
            SpawnAura(Player.TID, AURA_DARKBLUE + 1, false);
        if (Player.Aura[AURA_YELLOW] && !(GetCVar("drpg_simple_auras") == 0 && Shadow))
            SpawnAura(Player.TID, AURA_YELLOW + 1, false);
        if (Shadow)
            SpawnAura(Player.TID, AURA_MAX + 1, false);
    };
    
    // Decrease Aura Timer
    for (int i = 0; i < AURA_MAX; i++)
        if (Player.AuraTimer > 0 && Player.Aura[i])
            if (!CheckInventory("PowerTimeFreezer") && !CheckInventory("DRPGMenuFreezer"))
            {
                Player.AuraTimer--;
                break;
            };
    
    // Decrease Aura Cost Multiplier
    if (Player.AuraCostMult > 0)
        if ((Timer() % (35 * (30 + (GameSkill() * 5)))) == 0)
            Player.AuraCostMult -= 0.1;
    
    // Reset Aura and Soul States
    for (int i = 0; i < AURA_MAX; i++)
        if (Player.AuraTimer <= 0)
        {
            Player.Aura[i] = false;
            Player.SoulActive[i] = false;
        };
    
    // Summoned Monsters Handling
    for (int i = 0; i < MAX_SUMMONS; i++)
        if (Player.SummonTID[i] != 0 && GetActorProperty(Player.SummonTID[i], APROP_Health) <= 0)
        {
            Player.SummonTID[i] = 0;
            Player.Summons--;
        };
    
    // Force Wall Handling
    if (GetActorProperty(ForceFieldTID + PlayerNumber(), APROP_Alpha) > 0)
    {
        fixed WallAngle = GetActorAngle(0);
        fixed WallX = GetActorX(0) + Cos(WallAngle) * 48;
        fixed WallY = GetActorY(0) + Sin(WallAngle) * 48;
        fixed WallZ = GetActorZ(0);
        
        SetActorPosition(ForceFieldTID + PlayerNumber(), WallX, WallY, WallZ, false);
        SetActorAngle(ForceFieldTID + PlayerNumber(), WallAngle);
    };
    
    // Bullet-Time timer handling
    if (BulletTimeTimer > 0)
    {
        if (BulletTimeTimer % 3)
            GiveInventory("DRPGTimeFreezerQuick", 1);
        
        BulletTimeTimer--;
    };
};
