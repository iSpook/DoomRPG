#include "RPG.dh"

#include "Map.dh"
#include "Monsters.dh"
#include "Stats.dh"
#include "Outpost.dh"
#include "Utils.dh"

// Level Info
static LevelInfo *CurrentLevel;
static DynamicArray KnownLevels;
static int LastVisitedLevel;
static int AllBonusMaps; // For the OCD Shield

static DRLAEventMonsterReplacement[] NightmareReplacements =
{
    { "RLFormerHumanPistolRPG";             "RLEliteFormerHumanSpawner"; };
    { "RLFormerHumanBattleRifleRPG";        "RLEliteFormerHumanSpawner"; };
    { "RLFormerHumanBattleRifle2RPG";       "RLEliteFormerHumanSpawner"; };
    { "RLFormerHumanBattleRifle3RPG";       "RLEliteFormerHumanSpawner"; };
    { "RLFormerSergeantShotgunRPG";         "RLEliteFormerSergeantSpawner"; };
    { "RLFormerSergeantCombatShotgunRPG";   "RLEliteFormerSergeantSpawner"; };
    { "RLFormerCommandoChaingunRPG";        "RLEliteFormerCommandoSpawner"; };
    { "RLFormerCommandoBattleRifleRPG";     "RLEliteFormerCommandoSpawner"; };
    { "RLFormerCaptainPlasmaRifleRPG";      "RLEliteFormerCommandoSpawner"; };
    
    { "RLImpRPG";               "RLNightmareImpRPG"; };
    { "RLDemonRPG";             "RLNightmareDemonRPG"; };
    { "RLSpectreRPG";           "RLNightmareSpectreRPG"; };
    { "RLLostSoulRPG";          "RLNightmareLostSoulRPG"; };
    { "RLCacodemonRPG";         "RLNightmareCacodemonRPG"; };
    { "RLHellKnightRPG";        "RLNightmareHellKnightRPG"; };
    { "RLBaronOfHellRPG";       "RLNightmareBaronOfHellRPG"; };
    { "RLPainElementalRPG";     "RLNightmarePainElementalRPG"; };
    { "RLRevenantRPG";          "RLNightmareRevenantRPG"; };
    { "RLMancubusRPG";          "RLNightmareMancubusRPG"; };
    { "RLArachnotronRPG";       "RLNightmareArachnotronRPG"; };
    { "RLArchvileRPG";          "RLNightmareArchvileRPG"; };
    { "RLCyberdemonRPG";        "RLNightmareCyberdemonRPG"; };
    { "RLSpiderMastermindRPG";  "RLCyberneticSpiderMastermindRPG"; };
    
    { "RLCyberneticImpRPG";             "RLNightmareImpRPG"; };
    { "RLCyberneticDemonRPG";           "RLNightmareDemonRPG"; };
    { "RLCyberneticSpectreRPG";         "RLNightmareSpectreRPG"; };
    { "RLCyberneticLostSoulRPG";        "RLNightmareLostSoulRPG"; };
    { "RLCyberneticHellKnightRPG";      "RLNightmareHellKnightRPG"; };
    { "RLCyberneticBaronOfHellRPG";     "RLNightmareBaronOfHellRPG"; };
    { "RLCyberneticArachnotronRPG";     "RLNightmareArachnotronRPG"; };
    { "RLCyberneticMancubusRPG";        "RLNightmareMancubusRPG"; };
    { "RLCyberneticRevenantRPG";        "RLNightmareRevenantRPG"; };
    
    { nullptr; };
};

static DRLAEventMonsterReplacement[] TechnoReplacements =
{
    { "RLFormerHumanPistolRPG";             "RLEliteFormerHumanSpawner"; };
    { "RLFormerHumanBattleRifleRPG";        "RLEliteFormerHumanSpawner"; };
    { "RLFormerHumanBattleRifle2RPG";       "RLEliteFormerHumanSpawner"; };
    { "RLFormerHumanBattleRifle3RPG";       "RLEliteFormerHumanSpawner"; };
    { "RLFormerSergeantShotgunRPG";         "RLEliteFormerSergeantSpawner"; };
    { "RLFormerSergeantCombatShotgunRPG";   "RLEliteFormerSergeantSpawner"; };
    { "RLFormerCommandoChaingunRPG";        "RLEliteFormerCommandoSpawner"; };
    { "RLFormerCommandoBattleRifleRPG";     "RLEliteFormerCommandoSpawner"; };
    { "RLFormerCaptainPlasmaRifleRPG";      "RLEliteFormerCommandoSpawner"; };
    
    { "RLImpRPG";               "RLCyberneticImpRPG"; };
    { "RLDemonRPG";             "RLCyberneticDemonRPG"; };
    { "RLSpectreRPG";           "RLCyberneticSpectreRPG"; };
    { "RLLostSoulRPG";          "RLCyberneticLostSoulRPG"; };
    { "RLHellKnightRPG";        "RLCyberneticHellKnightRPG"; };
    { "RLBaronOfHellRPG";       "RLCyberneticBaronOfHellRPG"; };
    { "RLRevenantRPG";          "RLCyberneticRevenantRPG"; };
    { "RLMancubusRPG";          "RLCyberneticMancubusRPG"; };
    { "RLArachnotronRPG";       "RLCyberneticArachnotronRPG"; };
    { "RLSpiderMastermindRPG";  "RLCyberneticSpiderMastermindRPG"; };
    
    // Nightmare
    { "RLNightmareImpRPG";              "RLCyberneticImpRPG"; };
    { "RLNightmareDemonRPG";            "RLCyberneticDemonRPG"; };
    { "RLNightmareSpectreRPG";          "RLCyberneticSpectreRPG"; };
    { "RLNightmareLostSoulRPG";         "RLCyberneticLostSoulRPG"; };
    { "RLNightmareCacodemonRPG";        "RLCacodemonRPG"; };
    { "RLNightmareHellKnightRPG";       "RLCyberneticHellKnightRPG"; };
    { "RLNightmareBaronOfHellRPG";      "RLCyberneticBaronOfHellRPG"; };
    { "RLNightmareArachnotronRPG";      "RLCyberneticArachnotronRPG"; };
    { "RLNightmarePainElementalRPG";    "RLPainElementalRPG"; };
    { "RLNightmareRevenantRPG";         "RLCyberneticRevenantRPG"; };
    { "RLNightmareMancubusRPG";         "RLCyberneticMancubusRPG"; };
    { "RLNightmareArchvileRPG";         "RLArchvileRPG"; };
    { "RLNightmareCyberdemonRPG";       "RLCyberdemonRPG"; };
    
    { nullptr; };
};

static DRLAEventMonsterReplacement[] ArmageddonReplacements =
{
    { "RLFormerHumanPistolRPG";             "RLFormerCaptainPlasmaRifleRPG"; };
    { "RLFormerHumanBattleRifleRPG";        "RLFormerCaptainPlasmaRifleRPG"; };
    { "RLFormerHumanBattleRifle2RPG";       "RLFormerCaptainPlasmaRifleRPG"; };
    { "RLFormerHumanBattleRifle3RPG";       "RLFormerCaptainPlasmaRifleRPG"; };
    { "RLFormerSergeantShotgunRPG";         "RLFormerCaptainPlasmaRifleRPG"; };
    { "RLFormerSergeantCombatShotgunRPG";   "RLFormerCaptainPlasmaRifleRPG"; };
    { "RLFormerCommandoChaingunRPG";        "RLEliteFormerCaptainSpawner"; };
    { "RLFormerCommandoBattleRifleRPG";     "RLEliteFormerCaptainSpawner"; };
    { "RLFormerCaptainPlasmaRifleRPG";      "RLEliteFormerCaptainSpawner"; };
    
    { "RLImpRPG";               "RLArmageddonImpSpawner"; };
    { "RLDemonRPG";             "RLArmageddonDemonSpawner"; };
    { "RLSpectreRPG";           "RLArmageddonSpectreSpawner"; };
    { "RLLostSoulRPG";          "RLArmageddonLostSoulSpawner"; };
    { "RLCacodemonRPG";         "RLNightmareCacodemonRPG"; };
    { "RLHellKnightRPG";        "RLArmageddonHellKnightSpawner"; };
    { "RLBaronOfHellRPG";       "RLArmageddonBaronOfHellSpawner"; };
    { "RLPainElementalRPG";     "RLNightmarePainElementalRPG"; };
    { "RLRevenantRPG";          "RLArmageddonRevenantSpawner"; };
    { "RLMancubusRPG";          "RLArmageddonMancubusSpawner"; };
    { "RLArachnotronRPG";       "RLArmageddonArachnotronSpawner"; };
    { "RLArchvileRPG";          "RLNightmareArchvileRPG"; };
    { "RLCyberdemonRPG";        "RLNightmareCyberdemonRPG"; };
    { "RLSpiderMastermindRPG";  "RLCyberneticSpiderMastermindRPG"; };
    
    { nullptr; };
};

// Map Init Script
script void MapInit() open
{
    // Running the game for the first time
    if (KnownLevels.Data == nullptr)
    {
        ArrayCreate(&KnownLevels, "LVLS\x00", 32, sizeof(LevelInfo));
        CurrentLevel = NULL;
        
        if (KnownLevels.Data == nullptr)
        {
            Log("\cgWARNING: \caCould not allocate level info!\n");
            return;
        };
        
        // Special case for starting in the Outpost: Add MAP01 with some bogus info
        if (GetLevelInfo(LEVELINFO_LEVELNUM) == 999)
        {
            LevelInfo *DummyMap = &((LevelInfo *)KnownLevels.Data)[KnownLevels.Position++];
            DummyMap->LevelNum = 1;
            DummyMap->LumpName = "MAP01";
            DummyMap->NiceName = "Unknown Map";
            DummyMap->NeedsRealInfo = true;
            return;
        }
        else
        {
            // We don't need to Resize since the array size will always be 0 here
            CurrentLevel = &(((LevelInfo *)KnownLevels.Data)[KnownLevels.Position++]);
            // So that FindLevelInfoIndex can pick it up immediately
            CurrentLevel->LevelNum = GetLevelInfo(LEVELINFO_LEVELNUM);
            CurrentLevel->NeedsRealInfo = true;
        };
    };
    
    int Index = FindLevelInfoIndex();
    
    // The map has no level number
    if (Index == -3)
    {
        CurrentLevel = NULL;
        return;
    }
    else if (Index == -2) // UAC Outpost
    {
        CurrentLevel = NULL;
        SetupOutpostEvent();
        return;
    }
    else if (Index == -1) // New map - We need to create new info for it
    {
        CurrentLevel = &(((LevelInfo *)KnownLevels.Data)[KnownLevels.Position++]);
        CurrentLevel->NeedsRealInfo = true;
        
        if (KnownLevels.Position == KnownLevels.Size)
            ArrayResize(&KnownLevels);
    }
    else
        CurrentLevel = &(((LevelInfo *)KnownLevels.Data)[Index]);
    
    if (CurrentLevel->NeedsRealInfo)
    {
        CurrentLevel->LevelNum = GetLevelInfo(LEVELINFO_LEVELNUM);
        
        CurrentLevel->LumpName = StrParam("%N\n", PRINTNAME_LEVEL);
        CurrentLevel->NiceName = StrParam("%N\n", PRINTNAME_LEVELNAME);
        
        CurrentLevel->MaxMonstersKilled = GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
        CurrentLevel->MaxTotalMonsters = GetLevelInfo(LEVELINFO_TOTAL_MONSTERS);
        CurrentLevel->MaxMonsterPercentage = CalcPercent(GetLevelInfo(LEVELINFO_KILLED_MONSTERS), GetLevelInfo(LEVELINFO_TOTAL_MONSTERS));
        CurrentLevel->MaxItemsFound = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
        CurrentLevel->MaxTotalItems = GetLevelInfo(LEVELINFO_TOTAL_ITEMS);
        CurrentLevel->MaxItemPercentage = CalcPercent(GetLevelInfo(LEVELINFO_FOUND_ITEMS), GetLevelInfo(LEVELINFO_TOTAL_ITEMS));
        CurrentLevel->MaxSecretsFound = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
        CurrentLevel->MaxTotalSecrets = GetLevelInfo(LEVELINFO_TOTAL_SECRETS);
        CurrentLevel->MaxSecretPercentage = CalcPercent(GetLevelInfo(LEVELINFO_FOUND_SECRETS), GetLevelInfo(LEVELINFO_TOTAL_SECRETS));
        
        // For rank giving and mission counting
        CurrentLevel->UniqueSecrets = GetLevelInfo(LEVELINFO_FOUND_SECRETS);

        CurrentLevel->ShortestTime = 0x7FFFFFFF;
        
        // These never change so we don't need to update them
        CurrentLevel->Par = GetLevelInfo(LEVELINFO_PAR_TIME);
        CurrentLevel->Sucks = GetLevelInfo(LEVELINFO_SUCK_TIME);
        
        CurrentLevel->KillBonus = false;
        CurrentLevel->ItemsBonus = false;
        CurrentLevel->SecretsBonus = false;
        CurrentLevel->AllBonus = false;
        CurrentLevel->ParBonus = false;
        
        // Check to see if these are unobtainable
        if (CurrentLevel->MaxTotalMonsters == 0)
            CurrentLevel->KillBonus = true;
        if (CurrentLevel->MaxTotalItems == 0)
            CurrentLevel->ItemsBonus = true;
        if (CurrentLevel->MaxTotalSecrets == 0)
            CurrentLevel->SecretsBonus = true;
        if (CurrentLevel->MaxTotalMonsters == 0 && CurrentLevel->MaxTotalItems == 0 && CurrentLevel->MaxTotalSecrets == 0)
            CurrentLevel->AllBonus = true;
        if (CurrentLevel->Par == 0)
            CurrentLevel->ParBonus = true;
        CalculateBonusMaps();
        
        CurrentLevel->SelectedMonster = nullptr;
        CurrentLevel->LevelAdd = 0;
        CurrentLevel->RareAdd = 0;
    
        // Decide the map's event, if any
        DecideMapEvent();
        
        CurrentLevel->NeedsRealInfo = false;
    };
    
    // Delay to allow monsters to register themselves (See Monsters.ds:199)
    Delay(1);
    
    // Set up the currently in-effect map event
    SetupMapEvent();
    
    if (CurrentLevel)
        MapLoop();
};

script void DecideMapEvent()
{
    if (Random(1, 32) != 1)
        return; // No special event
    
    CurrentLevel->Event = Random(MAPEVENT_NONE + 1, MAPEVENT_MAX - 1);
    
    // *Really* rare
    if (CurrentLevel->Event == MAPEVENT_BONUS_RAINBOWS && Random(1, 4) != 1)
    {
        CurrentLevel->Event = MAPEVENT_NONE;
        return;
    };
    
    // Can't do Nightmare/Technophobia/Armageddon levels without DRLA
    if (CurrentLevel->Event >= MAPEVENT_DRLA_NIGHTMARE && CurrentLevel->Event <= MAPEVENT_DRLA_ARMAGEDDON && !GetCVar("drpg_ext_doomrl"))
    {
        CurrentLevel->Event = MAPEVENT_NONE;
        return;
    };
    
    auto str[MAPEVENT_MAX] EventNames =
    {
        "None";
        
        "MegaBoss";
        "Environmental Hazard";
        "Thermonuclear Bomb";
        "Low Power";
        "All Auras";
        "One-Monster";
        "Hell Unleashed";
        
        "RAINBOWS!";
        
        "DRLA - Nightmare!";
        "DRLA - Technophobia";
        "DRLA - Armageddon";
    };
    
    if (GetCVar("drpg_debug") && CurrentLevel->Event > 0)
        Log("\cdDEBUG: Special Event: \cg%s\n", EventNames[CurrentLevel->Event]);
};

script void SetupMapEvent()
{
    switch (CurrentLevel->Event)
    {
        // Normal Events
        // --------------------------------------------------
        
        case MAPEVENT_MEGABOSS:
            // Megaboss: One incredibly powerful super-monster spawns, nothing else in level.
            MegaBossEvent();
            break;
        
        case MAPEVENT_TOXICHAZARD:
            // Environmental Hazard: Entire map is filled with damaging radiation. Monsters can drop extra Radiation Suits when killed.
            EnvironmentalHazard();
            for (int i = 0; i < 65536; i++)
            {
                Light_ChangeToValue(i, 128);
                Sector_SetFade(i, 63, 131, 47);
            };
            break;
        
        case MAPEVENT_NUCLEARBOMB:
            // Thermonuclear Bomb: A Thermonuclear Bomb spawns next to you on map start. You have PAR * 3 to escape before it explodes.
            ThermonuclearBomb();
            break;
        
        case MAPEVENT_LOWPOWER:
            // Low Power: Light levels are extremely diminished. IR goggles recommended.
            for (int i = 0; i < 65536; i++)
            {
                Light_Flicker(i, 48, 96);
                Sector_SetColor(i, 64, 96, 255, 0);
            };
            break;
        
        case MAPEVENT_ALLAURAS:
            // All Auras: Self-Explanatory.
            // Nothing to do here.
            break;
        
        case MAPEVENT_ONEMONSTER:
            // One-Monster: All monsters are of a single type.
            OneMonsterEvent();
            break;
        
        case MAPEVENT_HELLUNLEASHED:
            // Hell Unleashed: Monsters will continue to spawn in over time
            // Monster levels and rare drop rates will steadily increase while you stay in the level
            HellUnleashedEvent();
            break;
        
        // Bonus Events
        // --------------------------------------------------
        
        case MAPEVENT_BONUS_RAINBOWS:
            // RAINBOWS: ALL OF THE COLORS!
            SetMusic("RAINBOWS");
            RainbowSectors();
            break;
        
        // DoomRL Exclusive
        // --------------------------------------------------
        
        case MAPEVENT_DRLA_NIGHTMARE:
            // DRLA - Nightmare!: All monsters are their Nightmare equivalents.
            DRLAReplaceMonsters(NightmareReplacements, "\c[Red]Just a nightmare. Just a nightmare...");
            break;
        
        case MAPEVENT_DRLA_TECHNOPHOBIA:
            // DRLA - Technophobia: All monsters are their Cybernetic equivalents.
            DRLAReplaceMonsters(TechnoReplacements, "\c[Grey]Hell has decided to roll out the big guns.");
            break;
        
        case MAPEVENT_DRLA_ARMAGEDDON:
            // DRLA - Armageddon: All monsters are their Armageddon equivalents.
            DRLAReplaceMonsters(ArmageddonReplacements, "\c[Black]The day of reckoning is upon you!");
            break;
        
        // Standard Level
        // --------------------------------------------------
        
        default:
            break;
    };
};

script void MegaBossEvent()
{
    bool Spawned;
    bool Spotted;
    int TID;
    int BossType;
    int Index;
    Position *ChosenPosition;
    
    auto DynamicArray MonsterPositions = BLANKDYNAMICARRAY;
    ArrayCreate(&MonsterPositions, "MPOS\x00", 64, sizeof(Position));
    
    // Ambient Music
    SetMusic(StrParam("MBossA%d\n", Random(1, 2)));
    
    Delay(1); // Maximize our instructions
    
    for (int i = 1; i < MAX_MONSTERS; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        // Array has grown too big, resize it
        if (MonsterPositions.Position == MonsterPositions.Size)
            ArrayResize(&MonsterPositions);
        
        // Store position
        ((Position *)MonsterPositions.Data)[MonsterPositions.Position++] = Monsters[i].Position;
        Monsters[i].ReplaceActor = "None";
    };
    
    Delay(2); // Monsters disappear!
    
    // Shuffle positions
    for (int i = 0; i < MonsterPositions.Position; i++)
    {
        int x = Random(0, MonsterPositions.Position - 1);
        Position TempPosition;
        
        TempPosition = ((Position *)MonsterPositions.Data)[i];
        ((Position *)MonsterPositions.Data)[i] = ((Position *)MonsterPositions.Data)[x];
        ((Position *)MonsterPositions.Data)[x] = TempPosition;
    };
    
    // Spawning
    while (!Spawned)
    {
        TID = UniqueTID();
        BossType = Random(0, MAX_MEGABOSSES - 1);
        ChosenPosition = &((Position *)MonsterPositions.Data)[Index];
        Spawned = Spawn(MegaBosses[BossType], ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z, TID, ChosenPosition->Angle * 256);
        
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: Iterating for Spawn Point... (Class %s, Index %d, Position %k/%k/%k\n", MegaBosses[BossType], Index, ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z);
        
        // Successful spawn
        if (Spawned)
        {
            SpawnForced("TeleportFog", ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z, 0, 0);
            GiveActorInventory(TID, "DRPGMegaBoss", 1);
            GiveActorInventory(TID, "DRPGWhiteAuraGiver", 1);
            if (GetCVar("drpg_debug"))
                Log("\cdDEBUG: \cg%s MegaBoss successfully spawned\n", MegaBosses[BossType]);
        };
        
        Index++;
        Delay(1);
    };
    
    // EVIL WARNING LAUGHTER
    AmbientSound("mission/gottarget2", 127);
    
    while (true)
    {
        // Spotted
        if (!Spotted)
            for (int i = 0; i < MAX_PLAYERS; i++)
                if (CheckSight(TID, Players(i).TID, 0))
                {
                    SetMusic(StrParam("MBossC%d\n", Random(1, 2)));
                    Spotted = true;
                    break;
                };
        
        // Defeated
        if (GetActorProperty(TID, APROP_Health) <= 0)
        {
            SetMusic("");
            CurrentLevel->Event = MAPEVENT_NONE;
            return;
        };
        
        Delay(1);
    };
};

script void EnvironmentalHazard()
{
    // TODO: [02:47:04] <<@Yholl/ID>> Have some sort of radiation device that sciences away the radiation
    Start:
    
    SectorDamage(0, 10, "Radiation", "PowerIronFeet", DAMAGE_PLAYERS | DAMAGE_IN_AIR | DAMAGE_SUBCLASSES_PROTECT);
    
    Delay(35);
    goto Start;
};

script void ThermonuclearBomb()
{
    // TODO: The ability to defuse the bomb and set one up yourself
    SetHudSize(640, 480, 0);
    
    int BombTime = GetLevelInfo(LEVELINFO_PAR_TIME) ? GetLevelInfo(LEVELINFO_PAR_TIME) * 3 : 300;
    BombTime *= 35;
    
    int Minutes = BombTime / 35 / 60;
    int Seconds = BombTime / 35 % 60;
    
    SetMusic("");
    
    Delay(35);
    
    SetFont("BIGFONT");
    HudMessageBold("\cgWARNING! WARNING!\n\c[White]THERMONUCLEAR BOMB ACTIVATED!\n\ciTIME UNTIL DETONATION: %s\n",
        FormatTime(BombTime), HUDMSG_TYPEON, 0, CR_RED, 320.4, 160.0, 3.0, 0.03, 0.5);
    AmbientSound("event/nukealert", 127);
    
    Delay(35 * 4);
    
    SetMusic("Bomb");
    
    while (BombTime)
    {
        Minutes = BombTime / 35 / 60;
        Seconds = BombTime / 35 % 60;
        
        SetFont("BIGFONT");
        HudMessageBold("\cgT - %s\n", FormatTime(BombTime), HUDMSG_FADEOUT, MAKE_ID('N', 'U', 'K', 'E'), CR_RED, 64.1, 64.1, 3.0, 0.5);
        
        BombTime--;
        
        Delay(1);
    };
    
    // Explosion
    AmbientSound("event/nukedetonate", 127);
    Thing_Destroy(0, 1);
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        if (!PlayerInGame(i))
            continue;
        
        Thing_Damage2(Players(i).TID, 12500, "Fire");
        Thing_Damage2(Players(i).TID, 12500, "Melee");
    };
    CurrentLevel->Event = MAPEVENT_NONE;
    SetMusic("");
    
    Delay(35 * 5);
    SetMusic("*");
};

script void OneMonsterEvent()
{
    bool DRLA = GetCVar("drpg_ext_doomrl");
    bool Extras = GetCVar("drpg_ext_extras");
    bool Brutal = GetCVar("drpg_ext_Brutal");
    
    if (CurrentLevel->SelectedMonster == nullptr)
    {
        if (DRLA)
            CurrentLevel->SelectedMonster = &MonsterDataDRLA[Random(0, MAX_DEF_MONSTERS_DRLA - 1)]
        else if (Brutal)
            CurrentLevel->SelectedMonster = &MonsterDataBrutal[Random(0, MAX_DEF_MONSTERS - 1)]
        else
            CurrentLevel->SelectedMonster = &MonsterData[Random(0, MAX_DEF_MONSTERS - 1)];
        
        if (GetCVar("drpg_debug") && CurrentLevel->Event > 0)
            Log("\cdDEBUG: Chosen Monster: \cg%s\n", CurrentLevel->SelectedMonster->Name);
    };

    for (int i = 1; i < MAX_MONSTERS; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        if (DRLA)
            Monsters[i].ReplaceActor = StrParam("%sRPG\n", CurrentLevel->SelectedMonster->Actor)
        else if (Extras)
            Monsters[i].ReplaceActor = StrParam("DRPG%sExtras\n", CurrentLevel->SelectedMonster->Actor)
        else if (Brutal)
            Monsters[i].ReplaceActor = StrParam("%sBD\n", CurrentLevel->SelectedMonster->Actor)
        else
            Monsters[i].ReplaceActor = StrParam("DRPG%s\n", CurrentLevel->SelectedMonster->Actor);
        
        // if (GetCVar("drpg_debug"))
        //     Log("\cdDEBUG: Monster Actor: \cg%s\n", Monsters[i].ReplaceActor);
    };
    
    // Level feeling
    SetHudSize(640, 480, false);
    SetFont("BIGFONT");
    HudMessage("%s\n", CurrentLevel->SelectedMonster->Feeling, HUDMSG_FADEOUT, 0, CR_BRICK, 320.0, 150.0, 1.0, 19.0);
};

script void HellUnleashedEvent()
{
    SetHudSize(640, 480, false);
    
    while (true)
    {
        // Spawn in new enemies
        if ((Timer() % (35 * 30)) == 0)
            HellUnleashedSpawnMonsters();
        
        // HUD
        SetFont("MonLevel");
        HudMessageBold("A\n", HUDMSG_ALPHA, 0, CR_WHITE, 14.1, 100.0, 0.05, 0.75 + (Sin((fixed)Timer() / 32.0) * 0.25));
        SetFont("STAT8S");
        HudMessageBold("A\n", HUDMSG_ALPHA, 0, CR_WHITE, 22.1, 133.0, 0.05, 0.75 + (Sin((fixed)Timer() / 32.0) * 0.25));
        SetFont("BIGFONT");
        HudMessageBold("+%k\n", CurrentLevel->LevelAdd, HUDMSG_PLAIN, 0, CR_WHITE, 40.1, 100.0, 0.05);
        HudMessageBold("+%k%%\n", CurrentLevel->RareAdd, HUDMSG_PLAIN, 0, CR_GOLD, 40.1, 116.0, 0.05);
        
        // Slowly increment the values
        CurrentLevel->LevelAdd += RandomFixed(0.001, 0.01);
        CurrentLevel->RareAdd += RandomFixed(0.0001, 0.001);
        
        // Caps
        if (CurrentLevel->LevelAdd > 1000)
            CurrentLevel->LevelAdd = 1000;
        if (CurrentLevel->RareAdd > 100)
            CurrentLevel->RareAdd = 100;
        
        Delay(1);
    };
};

script void HellUnleashedSpawnMonsters()
{
    auto DynamicArray MonsterPositions = BLANKDYNAMICARRAY;
    ArrayCreate(&MonsterPositions, "MPOS\x00", 64, sizeof(Position));
    
    if (GetCVar("drpg_debug"))
        Log("\cdDEBUG: \c-Spawning next wave of monsters...\n");

    Delay(1); // Maximize our instructions
    
    for (int i = 1; i < MAX_MONSTERS; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        // Array has grown too big, resize it
        if (MonsterPositions.Position == MonsterPositions.Size)
            ArrayResize(&MonsterPositions);
        
        // Store position
        ((Position *)MonsterPositions.Data)[MonsterPositions.Position++] = Monsters[i].Position;
    };
    
    for (int i = 0; i < MonsterPositions.Position; i++)
    {
        int TID = UniqueTID();
        Position *CurrentPosition = &((Position *)MonsterPositions.Data)[i];;
        
        // Determine a monster
        MonsterInfoPtr Monster;
        if (GetCVar("drpg_ext_doomrl"))
            Monster = &MonsterDataDRLA[Random(0, MAX_DEF_MONSTERS_DRLA - 1)]
        else if (GetCVar("drpg_ext_Brutal"))
            Monster = &MonsterDataBrutal[Random(0, MAX_DEF_MONSTERS - 1)]
        else
            Monster = &MonsterData[Random(0, MAX_DEF_MONSTERS - 1)];
        
        bool Success = Spawn(Monster->Actor, CurrentPosition->X, CurrentPosition->Y, CurrentPosition->Z, TID, CurrentPosition->Angle);
        if (Success)
            Spawn("TeleportFog", CurrentPosition->X, CurrentPosition->Y, CurrentPosition->Z, 0, CurrentPosition->Angle);
        
        // Stagger the loop here so that we can make monsters appear to spawn in semi-randomly
        Delay(Random(1, 10));
        
        // Setup Stats
        MonsterStatsPtr Stats = &Monsters[GetMonsterID(TID)];
        Stats->Level += (int)CurrentLevel->LevelAdd;
        Stats->NeedReinit = true;
    };
};

script void RainbowSectors()
{
    fixed Angle = 0;
    int Red, Green, Blue;
    
    for (int i = 0; i < 65536; i++)
        Light_ChangeToValue(i, 176);
    
    Delay(1);
    
    Start:
    Angle -= 1.0 / 350;
    if (Angle < 0.0) Angle = 1.0 + Angle;
    Red = 128 + (Sin(Angle) * 128.0);
    Green = 128 + (Sin(Angle + 0.33) * 128.0);
    Blue = 128 + (Sin(Angle + 0.67) * 128.0);
    
    for (int i = 0; i < 65536; Sector_SetColor(i++, Red, Green, Blue, 128));
    
    Delay(1);
    goto Start;
};

script void DRLAReplaceMonsters(DRLAEventMonsterReplacement *Replacements, str Message)
{
    for (int i = 1; i < MAX_MONSTERS; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        for (int j = 0; Replacements[j].SourceMonster != nullptr; j++)
        {
            if (!StrICmp(Monsters[i].Actor, Replacements[j].SourceMonster))
                Monsters[i].ReplaceActor = Replacements[j].DestMonster;
            if (GetCVar("drpg_debug"))
                Log("\cdDEBUG: Replacing \cg%s\cd with \cg%s\n", Monsters[i].Actor, Monsters[i].ReplaceActor);
        };
    };
    
    SetHudSize(640, 480, false);
    SetFont("BIGFONT");
    HudMessage("%s\n", Message, HUDMSG_FADEOUT, 0, CR_RED, 320.0, 150.0, 1.0, 19.0);
};

script void SetupOutpostEvent()
{
    // TODO: Outpost Invasions, Power Fluctuations
    return;
};

script void MapLoop()
{
    int XPBonus;
    int RankBonus;
    
    int ItemsFound;
    int SecretsFound;
    
    int ItemsLastFound = 0;
    
    Start:    
    // MISSION TRACKERS
    ItemsFound = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
    SecretsFound = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
    
    if (ItemsFound > ItemsLastFound)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i) || Players(i).Mission.Type != MT_ITEMS)
                continue;
            
            Players(i).Mission.Current += ItemsFound - ItemsLastFound;
        };
    };
    
    // These should be unique-only, because they're not secrets anymore once
    // you know about them.
    if (SecretsFound > CurrentLevel->UniqueSecrets)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0, 1.0);
            
            RankBonus = RankTable[Players(i).RankLevel] / 100;
            Players(i).Rank += RankBonus;
            
            if (Players(i).Mission.Type != MT_SECRETS)
                continue;

            Players(i).Mission.Current += SecretsFound - CurrentLevel->UniqueSecrets;
        };
        
        CurrentLevel->UniqueSecrets = SecretsFound;
    };
    
    // KILL / ITEM / SECRET SPECIAL BONUSES
    
    if (CalcPercent(GetLevelInfo(LEVELINFO_KILLED_MONSTERS), GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)) > CurrentLevel->MaxMonsterPercentage)
    {
        CurrentLevel->MaxMonstersKilled = GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
        CurrentLevel->MaxTotalMonsters = GetLevelInfo(LEVELINFO_TOTAL_MONSTERS);
        CurrentLevel->MaxMonsterPercentage = CalcPercent(GetLevelInfo(LEVELINFO_KILLED_MONSTERS), GetLevelInfo(LEVELINFO_TOTAL_MONSTERS));
    };
    
    if (CalcPercent(GetLevelInfo(LEVELINFO_FOUND_ITEMS), GetLevelInfo(LEVELINFO_TOTAL_ITEMS)) > CurrentLevel->MaxItemPercentage)
    {
        CurrentLevel->MaxItemsFound = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
        CurrentLevel->MaxTotalItems = GetLevelInfo(LEVELINFO_TOTAL_ITEMS);
        CurrentLevel->MaxItemPercentage = CalcPercent(GetLevelInfo(LEVELINFO_FOUND_ITEMS), GetLevelInfo(LEVELINFO_TOTAL_ITEMS));
    };
    
    if (CalcPercent(GetLevelInfo(LEVELINFO_FOUND_SECRETS), GetLevelInfo(LEVELINFO_TOTAL_SECRETS)) > CurrentLevel->MaxSecretPercentage)
    {
        CurrentLevel->MaxSecretsFound = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
        CurrentLevel->MaxTotalSecrets = GetLevelInfo(LEVELINFO_TOTAL_SECRETS);
        CurrentLevel->MaxSecretPercentage = CalcPercent(GetLevelInfo(LEVELINFO_FOUND_SECRETS), GetLevelInfo(LEVELINFO_TOTAL_SECRETS));
    };
    
    if (CurrentLevel->MaxMonsterPercentage >= 100 && !CurrentLevel->KillBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(255, 0, 0, 0.25, 255, 0, 0, 0, 1.0);
            
            XPBonus = XPTable[Players(i).Level] / 100;
            Player.XP += XPBonus;
            
            HudMessage("100%% Monsters Killed!\n%d XP Bonus\n", XPBonus,
                       HUDMSG_FADEOUT, 0, CR_BRICK, 1.5, 0.4, 3.0, 3.0);
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->KillBonus = true;
    };

    if (CurrentLevel->MaxItemPercentage >= 100 && !CurrentLevel->ItemsBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(0, 255, 255, 0.25, 0, 255, 255, 0, 1.0);
            
            Players(i).EP = Players(i).EPMax;
            HealThing(1000000);
            
            HudMessage("100%% Items Found!\nFull HP/EP Restore\n",
                       HUDMSG_FADEOUT, 0, CR_LIGHTBLUE, 1.5, 0.6, 3.0, 3.0);
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->ItemsBonus = true;
    };

    if (CurrentLevel->MaxSecretPercentage >= 100 && !CurrentLevel->SecretsBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0, 1.0);
            
            RankBonus = RankTable[Players(i).RankLevel] / 20;
            Players(i).Rank += RankBonus;

            HudMessage("100%% Secrets Found!\n%d Rank Bonus\n", RankBonus,
                       HUDMSG_FADEOUT, 0, CR_YELLOW, 1.5, 0.8, 3.0, 3.0);
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->SecretsBonus = true;
    };
    
    if (CurrentLevel->KillBonus && CurrentLevel->ItemsBonus && CurrentLevel->SecretsBonus && !CurrentLevel->AllBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(255, 255, 255, 0.25, 255, 255, 255, 0, 1.0);
            
            XPBonus = XPTable[Players(i).Level] / 100;
            RankBonus = RankTable[Players(i).RankLevel] / 20;
            
            Players(i).XP += XPBonus;
            Players(i).Rank += RankBonus;
            
            Players(i).EP = Players(i).EPMax;
            HealThing(1000000);
            
            HudMessage("\ca100%% Monsters killed!\n\cn100%% Items Found!\n\ck100%% Secrets Found!\n\n\cj%d XP Bonus\n\ck%d Rank Bonus\n\cnFull HP/EP Restore\n",
                       XPBonus, RankBonus,
                       HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.2, 5.0, 5.0);
            
            // Payout Bonus Increase
            Players(i).PayBonus++;
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->AllBonus = true;
        CalculateBonusMaps();
    };
    
    if (CalcPercent(GetLevelInfo(LEVELINFO_KILLED_MONSTERS), GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)) >= 100 && (CurrentLevel->Event == MAPEVENT_ALLAURAS || CurrentLevel->Event == MAPEVENT_ONEMONSTER))
    {
        // All Auras and One-Monster events are ended by killing everything on the map
        if (Timer() > 4)
        {
            AmbientSound("misc/secret", 127);
            HudMessageBold("Everything falls silent.\n",
                HUDMSG_FADEOUT, 0, CR_LIGHTBLUE, 0.5, 0.7, 5.0, 5.0);
        };
        CurrentLevel->Event = MAPEVENT_NONE;
        CurrentLevel->SelectedMonster = nullptr;
    };
    
    Delay(1);
    
    ItemsLastFound = ItemsFound;
    
    goto Start;
};

// Level exit script
// Can't use NamedExecute in xlat, lame
acscript void MapExit(bool Secret) @ MAP_EXIT_SCRIPTNUM
{
    int ParTime = GetLevelInfo(LEVELINFO_PAR_TIME);
    bool Waiting = true;
    
    // How long it took to reach the exit
    int ExitTime = Timer() / 35;
    if (CurrentLevel->ShortestTime > ExitTime)
        CurrentLevel->ShortestTime = ExitTime;
    
    // Prevent level exit until everyone is outside the menu
    if (InMultiplayer && PlayerCount() > 1)
        while (Waiting)
        {
            Waiting = false;
            
            for (int i = 0; i < MAX_PLAYERS; i++)
                if (Players(i).InMenu || Players(i).InShop || Players(i).OutpostMenu > 0)
                    Waiting = true;
            
            Delay(35 * 3);
        };
    
    // Check par time and give bonus if you beat it
    if (ParTime > 0 && ExitTime < ParTime && (CurrentLevel && !CurrentLevel->ParBonus))
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            SetActivator(Players(i).TID);
            int RankBonus = RankTable[Players(i).RankLevel] / 20;
            
            FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0.0, 1.0);
            HudMessage("Par Time Beaten!\n%d Rank Bonus\n",
                       RankBonus,
                       HUDMSG_FADEOUT, 0, CR_GOLD, 1.5, 0.5, 3.0, 2.0);
        
            
            Players(i).Rank += RankBonus;
        };
        
        AmbientSound("misc/parbonus", 127);
        
        if (CurrentLevel)
            CurrentLevel->ParBonus = true;
        
        Delay(35 * 5);
    };
    
    // Remove the RAINBOWS event
    if (CurrentLevel && CurrentLevel->Event == MAPEVENT_BONUS_RAINBOWS)
        CurrentLevel->Event = MAPEVENT_NONE;
    
    // Now exit the level
    if (Secret)
        Exit_Secret(0)
    else
        Exit_Normal(0);
};

function int FindLevelInfoIndex(int LevelNum)
{
    if (LevelNum == 0)
        LevelNum = GetLevelInfo(LEVELINFO_LEVELNUM);
    
    if (LevelNum == 999)
        return -2; // Special value to mean the Outpost.
    if (LevelNum == 0)
        return -3; // The map has a bogus level number, so we just don't know.
    
    for (int i = 0; i < KnownLevels.Position; i++)
        if (((LevelInfo *)KnownLevels.Data)[i].LevelNum == LevelNum)
            return i;
    
    return -1;
};

script void CalculateBonusMaps()
{
    int count = 0;
    
    for (int i = 0; i < KnownLevels.Position; i++)
        if (((LevelInfo *)KnownLevels.Data)[i].AllBonus)
            count++;
    
    AllBonusMaps = count;
};

acscript void SetMapEvent(int Level, int ID)
{
    if (Level == 0)
        Level = GetLevelInfo(LEVELINFO_LEVELNUM);
    
    int LevelIndex = FindLevelInfoIndex(Level);
    if (LevelIndex == -2)
    {
        Log("\cgOutpost Events aren't implemented yet.\n");
        return;
    }
    else if (LevelIndex == -1 || LevelIndex == -3)
    {
        Log("\cgCan't set an event for that level - Visit it first.\n");
        return;
    };
    
    LevelInfo *MapToChange = &((LevelInfo *)KnownLevels.Data)[LevelIndex];
    MapToChange->Event = ID;
    if (CurrentLevel == MapToChange)
        Log("\cjYou will need to warp back to this level to see changes take effect.\n");
};
